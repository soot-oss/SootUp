{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What's SootUp?","text":"<p>SootUp is a complete overhaul of the good, old static analysis framework Soot.</p> <ul> <li>Transforms JVM bytecode to the intermediate representation Jimple.</li> <li>Provides ClassHierarchy generation</li> <li>CallGraph generation with different algorithms/precisions</li> <li>Inter-procedural data-flow analysis with the IDE/IFDS framework enabled by Heros</li> <li>Applies simple transformations on retrieving a methods Body (see BodyInterceptor)</li> <li>Provides serialization of the Jimple IR.</li> </ul> <p>Important</p> <p>SootUp is not a version update to Soot, it is a completely new implementation written from scratch that aims to be a leaner, modernized and developer friendly successor of Soot. It is not a Drop-In Replacement! The new architecture and API, renders it not trivial to update existing projects that were built on soot. Therefore we recommend using SootUp for greenfield projects. We hope improved type safety and streamlined mechanisms will aide you implementing and debugging your analysis tool. Unfortunately not every feature has been ported - If you miss something feel free to contribute a feature you miss from good old Soot.</p>"},{"location":"#why-sootup","title":"Why SootUp?","text":"<p>Over the 20+ years, SootUps predecessor Soot has evolved into a powerful framework, which is one of the most widely used tools in the static analysis community.  This evolution was guided by the needs of the community and carried out with ad-hoc improvements. As a result, Soot has become a tool that can do a multitude of things, but it is heavy and hard to maintain and comprehend. So there was the need to clean up the codebase e.g. improve the software architecture, remove legacy datastructures that weren't in the Java Runtime at the time of Soots creation, enforce validation to have a sane state, removing the necessity of arcane knowledge, document it more and more - to make Soot future prove. So we introduced Design changes in SootUp, which aim to address Soot's shortcomings. The goal is a lighter library that can easily be understood and maintained to be included in other projects.</p>"},{"location":"#supporters","title":"Supporters","text":"<p>The development of SootUp is financed by generous support from the German Research Foundation (DFG) and the Heinz Nixdorf Institute (HNI).</p> <p>Become a sponsor!</p>"},{"location":"analysisinput/","title":"Analysis Input","text":"<p>i.e. What should be analyzed. An <code>AnalysisInputLocation</code> points to code input SootUp can analyze. We ship multiple Implementations that can handle different input.</p> <p>Additionally you can specify a SourceType. This determines what is considered e.g. in the CallGraphs generation. Further you can specify a List of BodyInterceptors, which will optimize the raw Jimple IR that was transformed from the input.</p>"},{"location":"analysisinput/#java-runtime","title":"Java Runtime","text":""},{"location":"analysisinput/#java-8","title":"Java &lt;=8","text":"<p>The <code>DefaultRTJaAnalysisInputLocation</code> points to the rt.jar of the executing JVM.</p> <pre><code>AnalysisInputLocation inputLocation = new DefaultRTJaAnalysisInputLocation();\nJavaView view = new JavaView(inputLocation);\n</code></pre> <p>To include a different Java Runtime library point to any rt.jar via a <code>JavaClassPathAnalysisInputLocation</code> as its a usual .jar file.</p>"},{"location":"analysisinput/#java-9","title":"Java &gt;=9","text":"<p>The <code>JRTFilesystemAnalysisInputLocation</code> points to the jigsawed java runtime of the executing JVM.  </p> <pre><code>AnalysisInputLocation inputLocation = new JrtFileSystemAnalysisInputLocation(); \nJavaView view = new JavaView(inputLocation);\n</code></pre> <p>If you have errors like Java.lang.String, Java.lang.Object, ... you are most likely missing this AnalysisInputLocation.</p>"},{"location":"analysisinput/#java-bytecode","title":"Java Bytecode","text":"<p>File-Extensions: <code>.class, .jar, .war</code></p> <p>The <code>JavaClassPathAnalysisInputLocation</code> is the equivalent of the classpath you would pass to the java executable i.e. point to root(s) of package(s).</p> Directory.jar File.class FileComplete class path <pre><code>AnalysisInputLocation inputLocation =\n        new JavaClassPathAnalysisInputLocation(\"target/\");  // points to\nJavaView view = new JavaView(inputLocation);\n</code></pre> <pre><code>AnalysisInputLocation inputLocation = new JavaClassPathAnalysisInputLocation(\"myCode.jar\");\nJavaView view1 = new JavaView(inputLocation);\n\n// if you want to analyze a specific language level of a multi release jar\nAnalysisInputLocation inputLocation =\n        new MultiReleaseJarAnalysisInputLocation(\"myCode.jar\", new JavaLanguage(10) );\nJavaView view2 = new JavaView(inputLocation);\n</code></pre> <pre><code>// if you omit the package structure while pointing to a file,\n// you have to pass the omitted directories as a parameter\nAnalysisInputLocation inputLocation = new PathBasedAnalysisInputLocation.\n            ClassFileBasedAnalysisInputLocation(\"Banana.class\", \"packageName.subPackage\", SourceType.Application);\nJavaView view = new JavaView(inputLocation);\n</code></pre> <pre><code>String cp = \"myCode.jar\" + File.pathSeparator + \"dependency.jar\" + File.pathSeparator + \"target/classes/\";\nAnalysisInputLocation inputLocation = new JavaClassPathAnalysisInputLocation(cp);\nJavaView view = new JavaView(inputLocation);\n</code></pre>"},{"location":"analysisinput/#java-sourcecode","title":"Java Sourcecode","text":"<p>File-Extensions: <code>.java</code></p> <p>With the <code>OTFCompileAnalysisInputLocation</code> you can point directly to .java files or pass a String with Java sourcecode. The AnalysisInputLocation delegates the data to the <code>JavaCompiler</code> and transform the bytecode from the compiler to Jimple.</p> Single FileMultiple FilesFile as String <pre><code>AnalysisInputLocation inputLocation = new OTFCompileAnalysisInputLocation(\"Banana.java\");\nJavaView view = new JavaView(inputLocation);\n</code></pre> <pre><code>List&lt;Path&gt; files = Arrays.asList(Paths.get(\"Apple.java\"), Paths.get(\"Banana.java\"));\nAnalysisInputLocation inputLocation = new OTFCompileAnalysisInputLocation(files);\nJavaView view = new JavaView(inputLocation);\n</code></pre> <pre><code>String content = \"public class B{ }\";\nAnalysisInputLocation location = new OTFCompileAnalysisInputLocation(\"B.java\", content );\nJavaView view = new JavaView(location);\n</code></pre> <p><code>JavaSourcePathInputLocation</code> experimental! - points to a directory that is the root source directory (containing the package directory structure).</p>"},{"location":"analysisinput/#jimple","title":"Jimple","text":"<p>File-Extensions: <code>.jimple</code></p> <p>The <code>JimpleAnalysisInputLocation</code> needs a Path to a .jimple file or a directory.</p> <pre><code>Path path = Paths.get(\"Banana.java\");\nAnalysisInputLocation jimpleLocation = new JimpleAnalysisInputLocation(path);\nJavaView view = new JavaView(jimpleLocation);\n</code></pre>"},{"location":"analysisinput/#android-bytecode","title":"Android Bytecode","text":"<p>File-Extensions: <code>.apk</code></p> <p>The <code>ApkAnalysisInputLocation</code> is the APK frontend written for Sootup</p> <pre><code>Path path = Paths.get(\"Banana.apk\");\nAnalysisInputLocation inputLocation = new ApkAnalysisInputLocation(path, \"\", DexBodyInterceptors.Default.bodyInterceptors());\nJavaView view = new JavaView(inputLocation);\n</code></pre>"},{"location":"analysisinput/#android-bytecode-with-dex2jar","title":"Android Bytecode with Dex2Jar","text":"<p>File-Extensions: <code>.apk</code></p> <p>If you prefer to use dex2jar as a base to transform android apps to jimple, you can add the code below to create your own analysis input location. We used the dependency de.femtopedia.dex2jar:dex2jar:2.4.22 in the given example. We recommend to use ApkAnalysisInputLocation</p> <pre><code>Path path = Paths.get(\"Banana.apk\");\nAnalysisInputLocation inputLocation = new Dex2JarAnalysisInputLocation(path);\nJavaView view = new JavaView(inputLocation);\n</code></pre> <pre><code>public class Dex2JarAnalysisInputLocation extends ArchiveBasedAnalysisInputLocation {\n\n    public Dex2JarAnalysisInputLocation(@Nonnull Path path, @Nullable SourceType srcType) {\n        super(path, srcType);\n        String jarPath = dex2jar(path);\n        this.path = Paths.get(jarPath);\n    }\n\n    private String dex2jar(Path path) {\n        String apkPath = path.toAbsolutePath().toString();\n        String outDir = \"./tmp/\";\n        int start = apkPath.lastIndexOf(File.separator);\n        int end = apkPath.lastIndexOf(\".apk\");\n        String outputFile = outDir + apkPath.substring(start + 1, end) + \".jar\";\n        Dex2jarCmd.main(\"-f\", apkPath, \"-o\", outputFile);\n        return outputFile;\n    }\n}\n</code></pre>"},{"location":"analysisinput/#combining-multiple-analysisinputlocations","title":"Combining Multiple AnalysisInputLocations","text":"<p>But what if I want to point to multiple AnalysisInputLocations?</p> <pre><code>AnalysisInputLocation mainJar = new JavaClassPathAnalysisInputLocation(\"myCode.jar\");\nAnalysisInputLocation jarA = new JavaClassPathAnalysisInputLocation(\"dependencyA.jar\");\nAnalysisInputLocation jarB = new JavaClassPathAnalysisInputLocation(\"dependencyB.jar\");\n\nList&lt;AnalysisInputLocation&gt; inputlocationList = Arrays.asList(mainJar, jarA, jarB);\n\nJavaView view = new JavaView(inputlocationList);\n</code></pre> <p>Of course you can combine different types of <code>AnalysisInputLocation</code>s as well!</p>"},{"location":"analysisinput/#maven-project-as-analysis-input-in-sootup","title":"Maven Project as Analysis Input in SootUp","text":"<p>This uses <code>mvn compile</code> + <code>JavaClassPathAnalysisInputLocation</code> under the hood to include a maven project. <pre><code>    TODO: let the code sail with the upstream boat to this doc.\n</code></pre></p> <p>Unfortunately its harder to extract the path of the binary result of Gradle projects in a unified way for all kinds of models - If you have a solution are looking forward to merge your contribution :-). </p>"},{"location":"analysisinput/#java-cli-arguments-to-configure-sootup","title":"Java cli arguments to configure SootUp","text":"<p>We created a Utility that parses a String of java command line arguments and configures SootUp respectively.</p>"},{"location":"announcement/","title":"Announcements","text":""},{"location":"announcement/#release-announcement","title":"Release Announcement","text":"<p>We would like to announce Soot\u2019s successor, SootUp. </p> <p>Over more than 20 years, Soot has become one of the world\u2019s most popular academic tool for Java and Android analysis and instrumentation. We thank all of you who have used and contributed to it over the years! It was your feedback and your contributions that helped it grow into such a versatile tool!</p> <p>However, over the years, the requirements for Soot have changed a lot, and given its original architecture, it was no longer quite up to the task. Soot was originally developed for ahead-of-time code transformation, particularly optimization, which has become very uncommon in Java. Current use cases center much more around powerful program analyses and program-understanding tasks.</p> <p>Today we are officially releasing SootUp, a new version of Soot with a completely overhauled architecture. With SootUp, we aim to keep the best things about Soot, yet overcome a lot of its drawbacks. We very much restructured Soot, particularly abolishing the heavy use of singletons. Soot now has a concept of views; each view corresponds to some version or variant of an analyzed program, and multiple views can be kept in memory at the same time. This sets the foundation, for instance, for differential or incremental program analyses.</p> <p>SootUp is a library that can easily be included in other projects, leaving those projects in control. For those who intend to use it as a framework, with inversion of control, SootUp provides additional templates that help you and novices to get started more easily. The Jimple IR has been slightly simplified, and has been made immutable by default such that internally SootUp can make use of caching where desired. Where required, Jimple transformations are still allowed, but in a systematic manner, for instance assuring that analyses depending on the transformed code are notified about its changes.</p> <p>Below is an overview of what\u2019s new. </p> <ul> <li>Library by default, framework as an option</li> <li>Modular Architecture, no more singletons</li> <li>New source code frontend </li> <li>Immutable Jimple IR</li> <li>Greatly increased testability and test coverage </li> </ul> <p>SootUp is not a drop-in replacement for Soot! Due to its completely new architecture and API it is essentially an almost complete rewrite. For a while, Soot and SootUp will coexist, as many existing tools depend on Soot, yet our maintenance efforts will henceforth be focused on SootUp, not Soot, and on extending SootUp with those capabilities that people still find missing. For now, we recommend using SootUp for greenfield projects.</p> <p>For more details, check out</p> <p>This Page ;-) and The SootUp repository: https://github.com/soot-oss/SootUp/</p> <p>We are very much looking forward to your feedback and feature requests. To this end, best create appropriate issues in the repository.</p> <p>This major upgrade of Soot was made possible by generous competitive funding by the DFG, within the project \u201cFuture-proofing the Soot Framework for Program Analysis and Transformation (FutureSoot)\u201d. It was funded in the DFG\u2019s program on Research Software Sustainability.</p>"},{"location":"bodyinterceptors/","title":"Body Interceptors","text":"<p>BodyInterceptors are applied to each <code>Body</code> now by default, if not overridden in the used AnalysisInputLocations. The BodyInterceptors exist to to improve and normalize the raw Jimple that was generated in an earlier step. The \"raw\" generated Jimple from the Bytecodefrontend needs a lot improvements - deficits of raw Jimple are:</p> <ul> <li>Java Variables with that are compiled to the same Local index, but from different scopes inside the method are mapped to the same Local. The Localsplitter takes care of splitting these Locals that are semantically different, into two seperate Local instances. </li> <li>The Conversion from a stack-machine to a register-machine creates leftover assignments - handled/inlined/removed by the Aggregator, CopyPropagator. They inline unnecessary Assignments.</li> <li>As the previous BodyTransformers could optimize code that leads to unused assignments etc - The DeadAssignmentEliminator keeps the StmtGraph clean from unused/dead Assignments.</li> <li>The Locals we get from the Java bytecode are typically untyped. Therefore we have to augment the Local types which is done by the TypeAssigner.</li> <li>t.b.c.</li> </ul> <p>Optimizations (method scope)</p> <ul> <li>ConditionalBranchFolder: removes tautologic ifs that are always true/false - if we can determine it in the scope of the method.</li> <li>EmptySwitchEliminator: removes switches that are not really switching</li> <li>ConstantPropagatorAndFolder: calculates constant values before runtime</li> <li>CastAndReturnInliner: Removes merging flows to a single return</li> <li>UnreachableCodeEliminator: speaks for itself.</li> <li>TrapTightener</li> </ul> <p>Standardize Jimple appearance</p> <ul> <li>LocalNameStandardizer: numbers Locals with the scheme: type-initial + number of type occurence </li> </ul> <p>Soot Equivalent</p> <p>BodyTransformer</p>"},{"location":"bodyinterceptors/#localsplitter","title":"LocalSplitter","text":"<p>LocalSplitter is a<code>BodyInterceptor</code>that attempts to identify and separate uses of a local variable (as definition) that are independent of each other by renaming local variables.</p> <p>Example 1: </p> <p></p> <p>As shown in the example above, the local variable<code>l1</code>is defined twice. It can be split up into two new local variables: <code>l1#1</code> and <code>l1#2</code> because the both definitions are independent of each other. </p> <p>Look for foldable navigation and tabs for showing old vs new</p> <p>Example 2:</p> <p></p> <p>In the second example, the local variable<code>l2</code>is defined thrice. But it cannot be split up into three new local variables as in the first example, because its definitions in the if-branches are not independent of each other. Therefore, it can only be split up into two local variables as shown in the figure.</p>"},{"location":"bodyinterceptors/#localpacker","title":"LocalPacker","text":"<p>LocalPacker is a<code>BodyInterceptor</code>that attempts to minimize the number of local variables which are used in body by reusing them, when it is possible. It corresponds to the inverse body transformation of LocalSplitter. Note: Every local variable's type should be assigned before running LocalPacker.</p> <p>Example:</p> <p></p> <p>In the given example above, the local variables<code>l1</code>,<code>l3</code>are summarized to be one local variable<code>l1</code>, because they have the same type without interference with each other. Likewise, the local variables<code>l2</code>,<code>l4</code>and<code>l5</code>are summarized to be another local variable<code>l2</code>. Although the local variable<code>l0</code>doesn't interfere any other local variables, it cannot be summed up with other local variables because of its distinctive type.</p>"},{"location":"bodyinterceptors/#traptightener","title":"TrapTightener","text":"<p>WIP - currently not available!</p> <p>TrapTightener is a<code>BodyInterceptor</code>that shrinks the protected area covered by each Trap in a Body. </p> <p>Example:</p> <p></p> <p>We assume in the example above that only the<code>Stmt</code>:<code>l2 := 2</code>might throw an exception caught by the<code>Trap</code>which is labeled with<code>label3</code>. In the jimple body before running the TrapTightener, the protected area covered by the Trap contains three<code>Stmts</code>:<code>l1 := 1; l2 := 2; l2 := 3</code>. But an exception could only arise at the<code>Stmt</code>:<code>l2 := 2</code>. After the implementation of TrapTightener, we will get a contractible protected area which contains only the<code>Stmt</code>that might throw an exception, namely the<code>Stmt</code>:<code>l2 := 2</code>.</p>"},{"location":"bodyinterceptors/#emptyswitcheliminator","title":"EmptySwitchEliminator","text":"<p>EmptySwitchEliminator is a<code>BodyInterceptor</code>that removes empty switch statements which contain only the default case.</p> <p>Example: </p> <p></p> <p>As shown in the example above, the switch statement in the jimple body always takes the default action. After running EmptySwitchEliminator, the switch statement is replaced with a<code>GotoStmt</code>to the default case.</p>"},{"location":"bodyinterceptors/#unreachablecodeeliminator","title":"UnreachableCodeEliminator","text":"<p>UnreachableCodeEliminator is a<code>BodyInterceptor</code>that removes all unreachable statements.</p> <p>Example: </p> <p></p> <p>Obviously, the code segment<code>l2 = 2; l3 = 3;</code>is unreachable. It will be removed after running the UreachableCodeEliminator.</p>"},{"location":"bodyinterceptors/#copypropagator","title":"CopyPropagator","text":"<p>CopyPropagator is a <code>BodyInterceptor</code> that supports copy propagation and constant propagation.</p> <p>CopyPropagator</p> <p>\"Definition 3[Copy Propagation]: The use of a variable y in the statement z=x+y occurring at a point p can be replaced by a variable w if every path from the entry node to point p contains the same definition y=w, for the variable y, and after the definition prior to reaching p, there is no redefinition to the variable y and no redefinition to the variable w.\"</p> <p>Sreekala, S. K. and Vineeth Kumar Paleri. \u201cCopy Propagation subsumes Constant Propagation.\u201d ArXiv abs/2207.03894 (2022): n. pag.</p> <p>Example for global copy propagation:</p> <p></p> <p>Consider a code segment in the following form: </p> <pre><code>a = b;\n...\nc = use(a); // a, b, c are local variables\n</code></pre> <p>According to the copy propagation's definition, the statement<code>c = use(a)</code>can be replaced with<code>c = use(b)</code>iff both conditions are met: </p> <ul> <li><code>a</code>is defined only one time on all the paths from<code>a = b</code>to<code>c = use(a)</code>.</li> <li>There are no definitions of<code>b</code>on any path from<code>a = b</code>to<code>c = use(a)</code>.</li> </ul> <p>In the example for global copy propagation, the first used<code>l1</code>is replaced with<code>l0</code>, but the second used<code>l1</code>cannot be replaced with<code>l3</code>, because the second condition is not satisfied.</p> <p>Example for constant propagation:</p> <p></p> <p>Constant propagation is similar to copy propagation. Consider a code segment in the following form:</p> <pre><code>a = const;\n...\nb = use(a); // a, b are local variables, const is a constant\n</code></pre> <p>After perfoming the constant propagation, the statement<code>b = use(a)</code>can be replaced with<code>b = use(const)</code>iff<code>a</code>is not redefined on any of the paths from<code>a = const</code>to<code>b = use(a)</code>.</p> <p>Therefore, the first used<code>l1</code>in the second example can be replaced with the constant<code>1</code>, but the second used<code>l1</code>cannot be replaced with the constant<code>2</code>, because<code>l1</code>is redefined on the path from<code>l1 = 2</code>to<code>l4 = use(l1)</code>.  However, it can be replaced with local variable<code>l2</code>, because the both conditions of copy propagation are met. </p>"},{"location":"bodyinterceptors/#localnamestandardizer","title":"LocalNameStandardizer","text":"<p>LocalNameStandardizer is a<code>BodyInterceptor</code>that assigns a generic name to each local variable. Firstly, it will sort the local variables' order alphabetically by the string representation of their type. If there are two local variables with the same type, then the LocalNameStandardizer will use the sequence of their occurrence in jimple body to determine their order.  Each assigned name consists of two parts:</p> <ul> <li>A letter to imply the local variable's type</li> <li>A digit to imply the local variable's order</li> </ul> <p>The following table shows the letter corresponding to each type:</p> Type of Local Variable Letter boolean z byte b short s int i long l float f double d char c null n unknown e reference r"},{"location":"bodyinterceptors/#staticsingleassignmentformer","title":"StaticSingleAssignmentFormer","text":"<p>StaticSingleAssignmentFormer is a<code>BodyInterceptor</code>that transforms jimple body into SSA form, so that each local variable is assigned exactly once and defined before its first use.</p> <p>Example:</p> <p></p> <p></p> <p>In the given example, the StaticSingleAssignmentFormer assigns each<code>IdentityStmt</code>and<code>AssignStmt</code>to a new local variable . And each use uses the local variable which is most recently defined. Sometimes, it is impossible to determine the most recently defined local variable for a use in a join block. In this case, the StaticSingleAssignmentFormer will insert a<code>PhiStmt</code>in the front of the join block to merge all most recently defined local variables and assign them a new local variable.</p>"},{"location":"builtin-analyses/","title":"BuiltIn Analyses","text":"<p>More to come!</p>"},{"location":"builtin-analyses/#locallivenessanalyser","title":"LocalLivenessAnalyser","text":"<p>LocalLivenessAnalyser is used for querying for the list of live local variables before and after a given <code>Stmt</code>.</p> <p>Example:</p> <p></p> <p>The live local variables before and after each <code>Stmt</code> will be calculated after generating an instance of LocalLivenessAnalyser as shown the example above. They can be queried by using the methods <code>getLiveLocalsBeforeStmt</code> and <code>getLiveLocalsAfterStmt</code>.</p>"},{"location":"builtin-analyses/#dominancefinder","title":"DominanceFinder","text":"<p>DomianceFinder is used for querying for the immediate dominator and dominance frontiers for a given basic block.</p> <p>Example:  </p> <p>After generating an instance of DominanceFinder for a <code>BlockGraph</code>, we will get the immediate dominator and dominance frontiers for each basic block. The both properties can be queried by using the methods<code>getImmediateDominator</code>and<code>getDominanceFrontiers</code>.</p>"},{"location":"callgraphs/","title":"Call Graph Construction","text":"<p>A call graph shows the method calling relationship of a program. It is a directed graph, whose nodes represent different methods, and edges represent caller -&gt; callee relationship.</p> <p>SootUp contains several call graph construction algorithms. Below, we show how you can use each of these.</p>"},{"location":"callgraphs/#creating-the-type-hierarchy","title":"Creating the Type Hierarchy","text":"<p>All the call graph construction algorithms require the view to access the type hierarchy for resolving method calls based of sub typing relationship. Below, we show how to create a type hierarchy:</p> SootUpSoot <pre><code>String cpString = \"src/test/resources/Callgraph/binary\";\nList&lt;AnalysisInputLocation&gt; inputLocations = new ArrayList();\ninputLocations.add(new JavaClassPathAnalysisInputLocation(cpStr));\ninputLocations.add(new DefaultRuntimeAnalysisInputLocation());\n\nJavaView view = new JavaView(inputLocations);\n</code></pre> <pre><code>String userdir = System.getProperty(\"user.dir\");\nString sootCp = userdir + File.separator + \"target\" + File.separator + \"test-classes\"+ File.pathSeparator + \"lib\"+File.separator+\"rt.jar\";\nString targetTestClassName = target.exercise1.Hierarchy.class.getName();\nG.reset();\nOptions.v().set_whole_program(true);\nOptions.v().set_soot_classpath(sootCp);\nOptions.v().set_no_bodies_for_excluded(true);\nOptions.v().process_dir();\nOptions.v().set_allow_phantom_refs(true);\nOptions.v().setPhaseOption(\"jb\", \"use-original-names:true\");\nOptions.v().set_prepend_classpath(false);\nSootClass c = Scene.v().forceResolve(targetTestClassName, SootClass.BODIES);\nif (c != null)\n    c.setApplicationClass();\nScene.v().loadNecessaryClasses();\n\nHierarchy hierarchy = new Hierarchy();\n</code></pre>"},{"location":"callgraphs/#defining-an-entry-method","title":"Defining an Entry Method","text":"<p>All call graph construction algorithms require an entry method to start with. In java application, you usually define the main method. However, it is possible to define arbitrary entry methods depending on your needs. Below, we show how to define such an entry method:</p> SootUp (performant)SootUp (alternative)Soot <pre><code>JavaClassType classTypeA = view.getIdentifierFactory().getClassType(\"packageNameA.A\");\n\nMethodSignature entryMethodSignature =\n    view.getIdentifierFactory()\n        .getMethodSignature(\n            classTypeA,\n            \"calc\",\n            VoidType.getInstance(),\n            Collections.singletonList(classTypeA)\n        );\n</code></pre> <pre><code>String methodSigStr = \"&lt;packageNameA.A: void calc(packageNameA.A)\";\nMethodSignature entryMethodSignature = view\n                    .getIdentifierFactory().parseMethodSignature(methodSigStr));\n</code></pre> <pre><code>String targetTestClassName = \"packageNameA.A\";\nSootMethod src = Scene.v().getSootClass(targetTestClassName).getMethodByName(\"doStuff\");     \n</code></pre>"},{"location":"callgraphs/#class-hierarchy-analysis","title":"Class Hierarchy Analysis","text":"<p>Class Hierarchy Analysis (CHA) algorithm is the most sound call graph construction algorithm available in SootUp. It soundly includes all implementers of an interface, when resolving a method call on an interface. You can construct a call graph with CHA as follows:</p> SootUpSoot <pre><code>CallGraphAlgorithm cha = new ClassHierarchyAnalysisAlgorithm(view);\n\nCallGraph cg = cha.initialize(Collections.singletonList(entryMethodSignature));\n\ncg.callsFrom(entryMethodSignature).stream()\n    .forEach(tgt -&gt; System.out.println(entryMethodSignature + \" may call \" + tgt);\n</code></pre> <pre><code>CHATransformer.v().transform();\nSootMethod src = Scene.v().getSootClass(targetTestClassName).getMethodByName(\"doStuff\");\nCallGraph cg = Scene.v().getCallGraph();\nIterator&lt;MethodOrMethodContext&gt; targets = new Targets(cg.edgesOutOf(src));\nwhile (targets.hasNext()) {\n    SootMethod tgt = (SootMethod)targets.next();\n    System.out.println(src + \" may call \" + tgt);\n}\n</code></pre>"},{"location":"callgraphs/#rapid-type-analysis","title":"Rapid Type Analysis","text":"<p>Rapid Type Analysis (RTA) algorithm constructs a rather precise version of the call graph that the CHA constructs. It refines CHA by considering only the instantiated implementers of an interface, when resolving a method call on an interface. You can construct a call graph with RTA as follows:</p> SootUpSoot <pre><code>CallGraphAlgorithm rta = new RapidTypeAnalysisAlgorithm(view);\n\nCallGraph cg = rta.initialize(Collections.singletonList(entryMethodSignature));\n\ncg.callsFrom(entryMethodSignature).stream()\n    .forEach(tgt -&gt; System.out.println(entryMethodSignature + \" may call \" + tgt);\n</code></pre> <pre><code>Transform sparkConfig = new Transform(\"cg.spark\", null);\nPhaseOptions.v().setPhaseOption(sparkConfig, \"enabled:true\");\nPhaseOptions.v().setPhaseOption(sparkConfig, \"rta:true\");\nPhaseOptions.v().setPhaseOption(sparkConfig, \"on-fly-cg:false\");\nMap phaseOptions = PhaseOptions.v().getPhaseOptions(sparkConfig);\nSparkTransformer.v().transform(sparkConfig.getPhaseName(), phaseOptions);\nSootMethod src = Scene.v().getSootClass(targetTestClassName).getMethodByName(\"doStuff\");\nCallGraph cg = Scene.v().getCallGraph();\nIterator&lt;MethodOrMethodContext&gt; targets = new Targets(cg.edgesOutOf(src));\nwhile (targets.hasNext()) {\n    SootMethod tgt = (SootMethod)targets.next();\n    System.out.println(src + \" may call \" + tgt);\n}  \n</code></pre>"},{"location":"callgraphs/#qilin-pointer-analysis","title":"Qilin Pointer Analysis","text":"<p>Qilin builds a call graph on the fly with the pointer analysis. You can construct a call graph with Qilin as follows:</p> <p>===\"SootUp\"</p> <pre><code>String MAINCLASS = \"dacapo.antlr.Main\"; // just an example\nPTAPattern ptaPattern = new PTAPattern(\"insens\"); // \"2o\"=&gt;2OBJ, \"1c\"=&gt;1CFA, etc.\nPTA pta = PTAFactory.createPTA(ptaPattern, view, MAINCLASS);\npta.run();\nCallGraph cg = pta.getCallGraph();\n</code></pre>"},{"location":"codepropertygraphs/","title":"Code Property Graphs","text":""},{"location":"codepropertygraphs/#dependencies","title":"Dependencies","text":"MavenGradle <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n&lt;artifactId&gt;sootup.codepropertygraph&lt;/artifactId&gt;\n&lt;version&gt;1.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>compile \"org.soot-oss:sootup.codepropertygraph:1.3.0\"\n</code></pre> <p>Code Property Graphs (CPGs) are a representation of program code that combines different code representations into a single graph. This unified representation includes abstract syntax trees (ASTs), control flow graphs (CFGs), control dependence graphs (CDGs), and data dependence graphs (DDGs). CPGs enable comprehensive analysis, which makes them a powerful tool for detecting vulnerabilities and understanding code structure. For further details, refer to this thesis.</p>"},{"location":"codepropertygraphs/#usage-example","title":"Usage Example","text":"<p>In this example, we will demonstrate how to create a CPG for a vulnerable Java method and use it to identify a potential vulnerability.</p>"},{"location":"codepropertygraphs/#vulnerable-java-code","title":"Vulnerable Java Code","text":"<p>Let's assume we have the following vulnerable Java code in a file named <code>VulnerableClass.java</code>:</p> Java <pre><code>public class VulnerableClass {\n    public void vulnerableMethod(String userInput) {\n        if (userInput.equals(\"admin\")) {\n            System.out.println(\"Welcome, admin!\");\n        }\n    }\n}\n</code></pre>"},{"location":"codepropertygraphs/#step-1-obtain-a-sootmethod","title":"Step 1: Obtain a SootMethod","text":"<p>First, we assume we have a <code>SootMethod</code> for the <code>vulnerableMethod</code>. For instructions on how to obtain a <code>SootMethod</code>, refer to Retrieving a Method.</p>"},{"location":"codepropertygraphs/#step-2-create-the-cpg","title":"Step 2: Create the CPG","text":"<p>We can create the CPG subgraphs using the creators.</p> ASTCFGCDGDDG <pre><code>public class AstExample {\n\n    public static void main(String[] args) {\n        // Assuming `sootMethod` is obtained from the setup step\n        SootMethod vulnerableMethod = getVulnerableMethod();\n\n        // Create the AST subgraph\n        AstCreator astCreator = new AstCreator();\n        PropertyGraph astGraph = astCreator.createGraph(vulnerableMethod);\n\n        // Print the DOT representation of the AST\n        System.out.println(astGraph.toDotGraph());\n    }\n}\n</code></pre> <pre><code>public class CfgExample {\n\n    public static void main(String[] args) {\n        // Assuming `sootMethod` is obtained from the setup step\n        SootMethod vulnerableMethod = getVulnerableMethod();\n\n        // Create the CFG subgraph         \n        CfgCreator cfgCreator = new CfgCreator();\n        PropertyGraph cfgGraph = cfgCreator.createGraph(vulnerableMethod);\n\n        // Print the DOT representation of the CFG\n        System.out.println(cfgGraph.toDotGraph());\n    }\n}\n</code></pre> <pre><code>public class CdgExample {\n\n    public static void main(String[] args) {\n        // Assuming `sootMethod` is obtained from the setup step\n        SootMethod vulnerableMethod = getVulnerableMethod();\n\n        // Create the CDG subgraph\n        CdgCreator cdgCreator = new CdgCreator();\n        PropertyGraph cdgGraph = cdgCreator.createGraph(vulnerableMethod);\n\n        // Print the DOT representation of the CDG\n        System.out.println(cdgGraph.toDotGraph());\n    }\n}\n</code></pre> <pre><code>public class DdgExample {\n\n    public static void main(String[] args) {\n        // Assuming `sootMethod` is obtained from the setup step\n        SootMethod vulnerableMethod = getVulnerableMethod();\n\n        // Create the DDG subgraph\n        DdgCreator ddgCreator = new DdgCreator();\n        PropertyGraph ddgGraph = ddgCreator.createGraph(vulnerableMethod);\n\n        // Print the DOT representation of the DDG\n        System.out.println(ddgGraph.toDotGraph());\n    }\n}\n</code></pre> <p>We can create the combined CPG graph using the <code>CpgCreator</code>.</p> CPG <pre><code>public class CpgExample {\n\n    public static void main(String[] args) {\n        // Assuming `sootMethod` is obtained from the setup step\n        SootMethod vulnerableMethod = getVulnerableMethod();\n\n        AstCreator astCreator = new AstCreator();\n        CfgCreator cfgCreator = new CfgCreator();\n        CdgCreator cdgCreator = new CdgCreator();\n        DdgCreator ddgCreator = new DdgCreator();\n\n        // Create the combined CPG\n        CpgCreator cpgCreator = new CpgCreator(astCreator, cfgCreator, cdgCreator, ddgCreator);\n        PropertyGraph cpg = cpgCreator.createCpg(vulnerableMethod);\n\n        // Print the DOT representation of the CPG\n        System.out.println(cpg.toDotGraph());\n    }\n}\n</code></pre>"},{"location":"codepropertygraphs/#step-3-analyzing-the-cpg","title":"Step 3: Analyzing the CPG","text":"<p>With the CPG created, you can now analyze it for vulnerabilities. For example, you can check for potential injection vulnerabilities by analyzing data flow dependencies.</p> SootUp <pre><code>public class VulnerabilityAnalysis {\n\n    public static void main(String[] args) {\n        // Assuming `cpg` is the PropertyGraph created in the previous step\n        for (DdgEdge edge : cpg.getEdges(DdgEdge.class)) {\n            StmtGraphNode source = (StmtGraphNode) edge.getSource();\n            StmtGraphNode destination = (StmtGraphNode) edge.getDestination();\n\n            if (isPotentiallyVulnerable(source, destination)) {\n                System.out.println(\"Potential vulnerability found between: \");\n                System.out.println(\"Source: \" + source.getStmt());\n                System.out.println(\"Destination: \" + destination.getStmt());\n            }\n        }\n    }\n\n    private static boolean isPotentiallyVulnerable(StmtGraphNode source, StmtGraphNode destination) {\n        // Implement your vulnerability detection logic here\n        return source.getStmt().toString().contains(\"userInput\") &amp;&amp; \n               destination.getStmt() instanceof JInvokeStmt &amp;&amp; \n               destination.getStmt().toString().contains(\"println\");\n    }\n}\n</code></pre> <p>In this example, we check for data flow dependencies between the <code>userInput</code> variable and any <code>println</code> calls, which could indicate a potential injection vulnerability.</p> <p>Similarly, we can define our own queries to detect specific patterns that identify common vulnerabilities.</p>"},{"location":"docguide/","title":"Docguide","text":""},{"location":"docguide/#general","title":"General","text":""},{"location":"docguide/#mkdocsextensions","title":"MkDocsExtensions","text":""},{"location":"docguide/#tooltip","title":"Tooltip","text":"<p>Hover me</p>"},{"location":"docguide/#example-file-inclusion","title":"Example File inclusion","text":"<p>this enables that tutorial code can be tested and will fail if its not up to date anymore :)</p> <pre><code>package sootup.examples.basicSetup;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Tag;\nimport org.junit.jupiter.api.Test;\nimport sootup.core.inputlocation.AnalysisInputLocation;\nimport sootup.core.jimple.common.expr.JVirtualInvokeExpr;\nimport sootup.core.jimple.common.stmt.JInvokeStmt;\nimport sootup.core.model.SootClass;\nimport sootup.core.model.SootMethod;\nimport sootup.core.model.SourceType;\nimport sootup.core.signatures.MethodSignature;\nimport sootup.core.types.ClassType;\nimport sootup.core.views.View;\nimport sootup.java.bytecode.frontend.inputlocation.PathBasedAnalysisInputLocation;\nimport sootup.java.core.language.JavaJimple;\nimport sootup.java.core.views.JavaView;\n\n/** This example illustrates how to create and use a new Soot Project. */\n@Tag(\"Java8\")\npublic class BasicSetup {\n\n  @Test\n  public void createByteCodeProject() {\n    // Create a AnalysisInputLocation, which points to a directory. All class files will be loaded\n    // from the directory\n    Path pathToBinary = Paths.get(\"src/test/resources/BasicSetup/binary\");\n    AnalysisInputLocation inputLocation =\n        PathBasedAnalysisInputLocation.create(pathToBinary, SourceType.Application);\n\n    // Create a view for project, which allows us to retrieve classes\n    View view = new JavaView(inputLocation);\n\n    // Create a signature for the class we want to analyze\n    ClassType classType = view.getIdentifierFactory().getClassType(\"HelloWorld\");\n\n    // Create a signature for the method we want to analyze\n    MethodSignature methodSignature =\n        view.getIdentifierFactory()\n            .getMethodSignature(\n                classType, \"main\", \"void\", Collections.singletonList(\"java.lang.String[]\"));\n\n    // Assert that class is present\n    assertTrue(view.getClass(classType).isPresent());\n\n    // Retrieve class\n    SootClass sootClass = view.getClass(classType).get();\n\n    // Retrieve method\n    view.getMethod(methodSignature);\n\n    // Alternatively:\n    assertTrue(sootClass.getMethod(methodSignature.getSubSignature()).isPresent());\n    SootMethod sootMethod = sootClass.getMethod(methodSignature.getSubSignature()).get();\n\n    // Read jimple code of method\n    System.out.println(sootMethod.getBody());\n\n    // Assert that Hello world print is present\n    assertTrue(\n        sootMethod.getBody().getStmts().stream()\n            .anyMatch(\n                stmt -&gt;\n                    stmt instanceof JInvokeStmt\n                        &amp;&amp; ((JInvokeStmt) stmt).getInvokeExpr().get() instanceof JVirtualInvokeExpr\n                        &amp;&amp; ((JInvokeStmt) stmt)\n                            .getInvokeExpr()\n                            .get()\n                            .getArg(0)\n                            .equivTo(JavaJimple.getInstance().newStringConstant(\"Hello World!\"))));\n  }\n}\n</code></pre>"},{"location":"examples/","title":"SootUp Example projects","text":"<p>Some examples that use SootUp to get insights about a Java program.</p> <ul> <li>Basic setup Example</li> <li>Configure a BodyInterceptor Example</li> <li>CallGraph Example</li> <li>Class Hierarchy Algoritm Example</li> <li>Replace a SootMethod of a SootClass Example</li> </ul> <p>Download</p> <p>The Examples can be cloned or downloaded from our Example Repository.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#how-to-setup-the-soot-dependency-in-maven-gradle","title":"How to setup the soot dependency (in Maven, Gradle)?","text":"<p>See Installation.</p>"},{"location":"faq/#how-to-retreive-a-sootclass-or-sootmethod","title":"How to retreive a SootClass or SootMethod?","text":"<p>See Getting Started.</p>"},{"location":"faq/#is-there-a-github-template-to-quickstart-into-development-with-sootup","title":"Is there a github template to quickstart into development with SootUp?","text":"<p>Not yet.</p>"},{"location":"faq/#error-while-using-the-sourcecodefrontend","title":"Error while using the Sourcecodefrontend","text":"<p>Please make sure to use Java8 to execute. </p>"},{"location":"faq/#exception-provider-jrt-not-found","title":"Exception: Provider \"jrt\" not found","text":"<p><pre><code>java.lang.ExceptionInInitializerError\n    at inputlocation.sootup.java.bytecode.frontend.JrtFileSystemAnalysisInputLocationTest.getClassSource(JrtFileSystemAnalysisInputLocationTest.java:28)\n    ...\nCaused by: java.nio.file.ProviderNotFoundException: Provider \"jrt\" not found\n</code></pre> To execute SootUp with JavaModules support please make sure you run the code at least the Java9 Runtime.</p>"},{"location":"faq/#how-to-solve-a-concurrentmodificationexception","title":"How to solve a ConcurrentModificationException?","text":"<p>Copy the Iterator into an intermediate Collection.  <pre><code>final StmtGraph&lt;?&gt; stmtGraph = builder.getStmtGraph();\n    for (Stmt stmt : Lists.newArrayList(stmtGraph)){\n        ...\n    }\n}\n</code></pre></p>"},{"location":"faq/#how-can-i-visualize-a-stmtgraph","title":"How can I visualize a StmtGraph?","text":"<p>There exists a tool, that converts a StmtGraph to the Graphviz Dot Language. <pre><code>DotExporter.buildGraph( stmtgraph );\n</code></pre> or create a convenient link with the exported stmtgraph as HTTP GET Parameter <pre><code>DotExporter.createUrlToWebeditor( stmtgraph );\n</code></pre></p>"},{"location":"faq/#the-sourcecodefrontend","title":"The Sourcecodefrontend...","text":"<p>is in a experimental state! If you wish to use it, please consider to contribute.</p>"},{"location":"faq/#is-there-a-way-to-use-code-exploration-and-syntax-highlighting-features-in-my-ide-for-jimple-files","title":"Is there a way to use code exploration and syntax highlighting features in my IDE for .jimple files?","text":"<p>Try JimpeLsp or the vscode plugin</p>"},{"location":"faq/#is-there-a-way-to-use-syntax-highlighting-of-jimple-in-my-paper-thesis","title":"Is there a way to use syntax highlighting of .jimple in my paper, thesis, ...?","text":"<p>Have a look at LspLexer4Pygments. Its the same syntax highlighting you see here in the documentation. You can export it to LaTex as well.</p>"},{"location":"faq/#how-to-add-an-entry-in-this-list-ie-your-question-is-not-answered-here","title":"How to ... add an entry in this list? i.e. Your question is not answered here?","text":"<p>Feel free to start a Discussion. </p>"},{"location":"getting-started/","title":"First Steps with SootUp","text":"<p>Before you get started with the SootUp library, it helps to learn about the following core data structures:</p> <ul> <li> <p><code>AnalysisInputLocation</code>   : points to the target code that shall be loaded into the <code>View</code>.</p> </li> <li> <p><code>View</code>: handles the representation of the code you configured it to analyze.</p> </li> <li> <p><code>SootClass</code>: represents a class. Can be loaded from the View via a <code>ClassType</code> identifier.</p> </li> <li><code>SootMethod</code>: represents a method of a class - loaded from the View via a <code>MethodSignature</code> identifier.</li> <li><code>SootField</code>: represents a field of a class - loaded from the View via a <code>FieldSignature</code> identifier.</li> <li><code>Body</code>: represents a method body of a <code>SootMethod</code>.</li> <li><code>StmtGraph</code>: represents the control flow graph of a <code>Body</code>. <code>Stmt</code>'s represent actual Instructions.</li> </ul>"},{"location":"getting-started/#creating-a-view","title":"Creating a View","text":"<p>You can use bytecode analysis typically when you do not have access to the source code of the target program. Following example shows how to create a view for analyzing Java bytecode.</p> <p>Create a view to analyze Java bytecode</p> <pre><code>AnalysisInputLocation inputLocation = \n        new JavaClassPathAnalysisInputLocation(\"path2Binary\");\n\nJavaView view = new JavaView(inputLocation);\n</code></pre> <p>If you have access to the source code, it is also possible to create a view for analyzing source code. Following example shows how to create view for analyzing Java source code.</p> <p>Experimental! - Create a view to analyze Java source code</p> <p>The source code frontend is experimental and should only be used for testing purposes.  Usually you should compile the code for analysis first and use the bytecode frontend instead (see above). </p> <pre><code>AnalysisInputLocation inputLocation = \n        new JavaSourcePathAnalysisInputLocation(\"path2Source\");\n\nJavaView view = new JavaView(inputLocation);\n</code></pre> <p>If you have a Jimple file, you can create a view for analyzing jimple code directly. Following example shows how to create a view for analyzing jimple code.</p> <p>Create a view to analyze jimple code</p> <pre><code>Path pathToJimple = Paths.get(\"path2Jimple\");\n\nAnalysisInputLocation inputLocation = \n        new JimpleAnalysisInputLocation(pathToJimple);\n\nJimpleView view = new JimpleView(inputLocation);\n</code></pre> <p>By default, whenever a class is retrieved, it will be permanently stored in a cache. If you do not want retrieved classes to be stored indefinetly, you can instead provide a different <code>CacheProvider</code> to the created view. To for example use an <code>LRUCache</code> instead, which stores at most e.g. 50 classes, and always replaces the least recently used class by a newly retrieved one, use the following call:</p> <pre><code>JavaView view = new JavaView(inputLocations, new LRUCacheProvider(50));\n</code></pre>"},{"location":"getting-started/#retrieving-a-class","title":"Retrieving a Class","text":"<p>Each class is identified with a unique signature adhering to Java identifier rules, therefore you first need to specify the class signature (<code>ClassType</code>) as shown below.</p> <p>Let's say the following is the target program that we want to analyze:</p> <p>Target Program</p> <pre><code>package example;\n\npublic class HelloWorld {\n\n  public HelloWorld() {\n\n  }\n\n  public static void main(String[] args) {\n    HelloWorld hw = new HelloWorld();\n    hw.hello();\n  }\n\n  public void hello() {\n\n  }\n\n}\n</code></pre> <p>Then, we could define the <code>ClassType</code> of the <code>HelloWorld</code> class as follows:</p> <p>Defining a ClassType</p> <pre><code>JavaClassType classType = \n        view.getIdentifierFactory().getClassType(\"example.HelloWorld\");\n</code></pre> <p>Once we have a <code>ClassType</code> that identifies the <code>HelloWorld</code> class, we can use it to retrieve the corresponding <code>SootClass</code> object from the <code>view</code> as shown below:</p> <p>Retrieving a SootClass</p> <pre><code>JavaSootClass sootClass = view.getClass(classType).get();\n</code></pre>"},{"location":"getting-started/#retrieving-a-method","title":"Retrieving a Method","text":"<p>Like the classes, methods also have an identifier which we call <code>MethodSignature</code>. For instance, we can define the method signature for identifying the <code>main</code> method of the <code>HelloWorld</code> class as follows:</p> <p>Defining a MethodSignature</p> PureParse from String <pre><code>MethodSignature methodSignature =\n    view\n        .getIdentifierFactory()\n        .getMethodSignature(\n            \"main\", // method name\n            classType,\n            \"void\", // return type\n            Collections.singletonList(\"java.lang.String[]\")); // args\n</code></pre> <pre><code>MethodSignature methodSignature =\n    view\n        .getIdentifierFactory()\n        .parseMethodSignature(\n            \"&lt;packageName.classType: void main(java.lang.String[])&gt;\");\n</code></pre> <p>Once we have a <code>MethodSignature</code> that identifies the <code>main</code> method of the <code>HelloWorld</code> class, we can use it to retrieve the corresponding <code>SootMethod</code> object from the <code>view</code> as shown below:</p> <p>Retrieving a SootMethod from the View</p> <pre><code>Optional&lt;SootMethod&gt; opt = view.getMethod(methodSignature);\n\nif(!opt.isPresent()){\n    return;\n}\nSootMethod method = opt.get();\nSystem.out.println(method.getModifiers());\n</code></pre> <p>Alternatively, we can also retrieve a <code>SootMethod</code> from <code>SootClass</code> that contains it.</p> <p>Retrieving a SootMethod from a SootClass</p> <pre><code>MethodSubSignature mss = methodSignature.getSubSignature()\nOptional&lt;JavaSootMethod&gt; opt = sootClass.getMethod(mss);\n\nif(opt.isPresent()){\n  JavaSootMethod method = opt.get();\n}\n</code></pre>"},{"location":"getting-started/#retrieving-the-control-flow-graph-of-a-method","title":"Retrieving the Control-Flow Graph of a Method","text":"<p>Each <code>SootMethod</code> contains a Control-Flow Graph (CFG) which is represented via the <code>StmtGraph</code>. This structure is usually used for program analysis. You can retrieve the CFG of a <code>SootMethod</code> as follows:</p> <p>Retrieving the CFG of a SootMethod</p> <pre><code>StmtGraph&lt;?&gt; graph = sootMethod.getBody().getStmtGraph();\n</code></pre>"},{"location":"getting-started/#using-the-stmtgraph","title":"Using the StmtGraph","text":"StmtGraph StmtsStmtGraph BlocksStmtGraph DotExport <pre><code>for( Stmt stmt : graph.nodes()){\n    // pseudo topological order as Stmts would be serialized to a Jimple file.\n}\n\nfor( Stmt stmt : graph.nodes()){\n    // Stmts are unordered!\n}\n</code></pre> <pre><code>List&lt;BasicBlock&lt;?&gt;&gt; blocks = graph.getBlocks();\nfor( BasicBlock&lt;?&gt; block : blocks){\n    // e.g. check if its a merge point\n    if(block.getPredecessors().size() &gt; 1){\n        ...\n    }\n\n    // e.g. check if its a branching point\n    if(block.getSuccessors().size() &gt; 1){\n        // or use block.getTail() instanceof BranchingStmt\n        ...\n    }\n\n    // e.g. check if thrown exceptions would be caught in this method\n    if(!block.getExceptionalSuccessors().isEmpty()){\n        ...\n    }\n}\n</code></pre> <pre><code>String urlToWebeditor = DotExporter.createUrlToWebeditor(this);\nSystem.out.println(urlToWebeditor);\n</code></pre> <p>Access a complete example of the code used above</p> <p>Download BasicSetup.java</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#use-the-latest-develop-branch","title":"Use the latest develop branch","text":"<p>For configuration options of your build tool please visit SootUp on Jitpack.io</p>"},{"location":"installation/#use-releases-on-maven-central","title":"Use Releases on Maven Central","text":"<p>The code below shows you how to import all submodules of the SootUp repository. You can import fewer modules if your use case allows it.</p> <p>Add the following dependencies to your <code>pom.xml</code> / <code>build.gradle</code>.</p> MavenGradle <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n        &lt;artifactId&gt;sootup.core&lt;/artifactId&gt;\n        &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n        &lt;artifactId&gt;sootup.java.core&lt;/artifactId&gt;\n        &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n        &lt;artifactId&gt;sootup.java.sourcecode.frontend&lt;/artifactId&gt;\n        &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n        &lt;artifactId&gt;sootup.java.bytecode.frontend&lt;/artifactId&gt;\n        &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n        &lt;artifactId&gt;sootup.jimple.frontend&lt;/artifactId&gt;\n        &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n        &lt;artifactId&gt;sootup.apk.frontend&lt;/artifactId&gt;\n        &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n        &lt;artifactId&gt;sootup.callgraph&lt;/artifactId&gt;\n        &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n        &lt;artifactId&gt;sootup.analysis.intraprocedural&lt;/artifactId&gt;\n        &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n        &lt;artifactId&gt;sootup.analysis.interprocedural&lt;/artifactId&gt;\n        &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n        &lt;artifactId&gt;sootup.qilin&lt;/artifactId&gt;\n        &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n        &lt;artifactId&gt;sootup.codepropertygraph&lt;/artifactId&gt;\n        &lt;version&gt;1.3.0&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <pre><code>repositories {\n    mavenCentral()\n    google()\n}\n\ncompile \"org.soot-oss:sootup.core:1.3.0\"\ncompile \"org.soot-oss:sootup.java.core:1.3.0\"\ncompile \"org.soot-oss:sootup.java.sourcecode.frontend:1.3.0\"\ncompile \"org.soot-oss:sootup.java.bytecode.frontend:1.3.0\"\ncompile \"org.soot-oss:sootup.jimple.frontend:1.3.0\"\ncompile \"org.soot-oss:sootup.apk.frontend:1.3.0\"\ncompile \"org.soot-oss:sootup.callgraph:1.3.0\"\ncompile \"org.soot-oss:sootup.analysis.intraprocedural:1.3.0\"\ncompile \"org.soot-oss:sootup.analysis.interprocedural:1.3.0\"\ncompile \"org.soot-oss:sootup.qilin:1.3.0\"\ncompile \"org.soot-oss:sootup.codepropertygraph:1.3.0\"\n</code></pre>"},{"location":"installation/#build-from-source","title":"Build from Source","text":"<p>If you'd like to get the most recent changes, you can build SootUp from source yourself and install it into your local maven repository. <pre><code>git clone https://github.com/secure-software-engineering/SootUp.git\nmvn install\n</code></pre></p>"},{"location":"jimple-body/","title":"Jimple Body","text":"<p>A SootMethod <code>Body</code> consists of the <code>Modifiers</code> and its <code>StmtGraph</code> - SootUps Control Flow Graph Structure. The StmtGraph models the flow of Stmts.</p>"},{"location":"jimple-body/#control-flow-graph","title":"Control Flow Graph","text":"<ul> <li>unexceptional flow -&gt; like FallsThroughStmts and BranchingStmts for if,goto etc.</li> <li>exceptional flow -&gt; for exceptions, handled by traps.</li> </ul>"},{"location":"jimple-body/#stmts","title":"Stmts","text":"<p>Learn more about the types of Stmts.</p>"},{"location":"jimple-body/#traps","title":"Traps","text":"<p>A Trap is a mechanism to model exceptional flow. A Trap represents the try-catch (finally) construct and therefore defines the type of the caught exception, the try-catch range (from-to) and the actual code that handles the exception (handler). In serialized(!) Jimple Labels are used to denote from,to and handler Stmts.</p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public void divideExample(int, int)\n  {\n    int x, y, $stack4;\n    java.io.PrintStream $stack5, $stack7;\n    java.lang.Exception $stack6;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    x := @parameter0: int;\n    y := @parameter1: int;\n\n   label1:\n      $stack5 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack4 = x / y;\n      virtualinvoke $stack5.&lt;java.io.PrintStream: void println(int)&gt;($stack4);\n\n   label2:\n      goto label4;\n\n   label3:\n      $stack6 := @caughtexception;\n      $stack7 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack7.&lt;java.io.PrintStream: \n        void println(java.lang.String)&gt;(\"Exception caught\");\n\n   label4:\n      return;\n\n      catch java.lang.Exception from label1 to label2 with label3;\n  }\n}\n/*\n  By calling getTraps() method, we can get the Traip chain.\n  For the above jimple code, we have the below trap:\n  Trap :\n  begin  : $stack5 = &lt;java.lang.System: java.io.PrintStream out&gt;\n  end    : goto [?= return]\n  handler: $stack6 := @caughtexception\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public void divideExample(int x, int y){\n    try {\n      System.out.println(x / y);\n    }catch (Exception e){\n      System.out.println(\"Exception caught\");\n    }\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n    L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic divideExample(II)V\n  TRYCATCHBLOCK L0 L1 L2 java/lang/Exception\n  L0\n    LINENUMBER 6 L0\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 1\n    ILOAD 2\n    IDIV\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L1\n    LINENUMBER 9 L1\n    GOTO L3\n  L2\n    LINENUMBER 7 L2\n    FRAME SAME1 java/lang/Exception\n    ASTORE 3\n  L4\n    LINENUMBER 8 L4\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Exception caught\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L3\n    LINENUMBER 10 L3\n    FRAME SAME\n    RETURN\n  L5\n    LOCALVARIABLE e Ljava/lang/Exception; L4 L3 3\n    LOCALVARIABLE this Land Ttarget/exercise1/DemoClass; L0 L5 0\n    LOCALVARIABLE x I L0 L5 1\n    LOCALVARIABLE y I L0 L5 2\n    MAXSTACK = 3\n    MAXLOCALS = 4\n}\n</code></pre>"},{"location":"jimple-stmts/","title":"Jimple Stmt (\"Statement\")","text":"<p>Stmts represent instructions of the JVM. Jimple is a 3-address form code so there are max 3 operands used in a (\"manipulating\") Stmt - i.e. this does not apply to invokes as this is just operand/parameter passing.</p> <p>Stmts can be roughly grouped by the amount of successors (in the <code>StmtGraph</code> of a <code>Body</code> of a <code>Method</code>).</p> <ul> <li>A <code>FallsThroughStmt</code> has always one successor - it basically represents <code>program counter++</code>.</li> <li>A <code>BranchingStmt</code> can have one, two or even n successors.</li> <li>All others (neither FallsThrough nor BranchingStmt) have no successors and therefore end the execution of the current method.</li> </ul>"},{"location":"jimple-stmts/#branching-stmts","title":"Branching Stmts","text":"<p>A BranchingStmt's job is to model the jumps or conditional branching flow between Stmts.</p>"},{"location":"jimple-stmts/#jgotostmt","title":"JGotoStmt","text":"<p>represents unconditional jumps to another Stmt.  </p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n  public static void sampleMethod()\n  {\n    int i;\n    i = 0;\n\n    label1:\n      if i &gt;= 5 goto label3;\n      if i != 3 goto label2;\n      goto label3;\n\n    label2:\n      i = i + 1;\n      goto label1;\n\n    label3:\n      return;\n  }\n}\n/*\n  Here for statements \"goto label3;\" and \"goto label1;\", \n  we have two instances of JGotoStmt : \n    \"goto[?=return]\" and \"goto[?=(branch)]\".\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public static void sampleMethod(){\n    label1:\n    for (int i = 0; i &lt; 5; i++){\n      if(i == 3){\n        break label1;\n      }\n    }\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x9\npublic static sampleMethod()V\n  L0\n    LINENUMBER 6 L0\n    ICONST_0\n    ISTORE 0\n  L1\n    FRAME APPEND [I]\n    ILOAD 0\n    ICONST_5\n    IF_ICMPGE L2\n  L3\n    LINENUMBER 7 L3\n    ILOAD 0\n    ICONST_3\n    IF_ICMPNE L4\n  L5\n    LINENUMBER 8 L5\n    GOTO L2\n  L4\n    LINENUMBER 6 L4\n    FRAME SAME\n    IINC 0 1\n    GOTO L1\n  L2\n    LINENUMBER 11 L2\n    FRAME CHOP 1\n    RETURN\n    LOCALVARIABLE i I L1 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple-stmts/#jifstmt","title":"JIfStmt","text":"<p>For conditional jumps depending on the result of the conditional expression <code>AbstractConditionExpr</code> which needs to have boolean result. If the conditional expression is false, the next Stmt is the successor as the JIFStmt is also a <code>FallsthroughStmt</code>. Therefore, the JIfStmt has two successor Stmt's.</p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n   public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public static void sampleMethod(int)\n  {\n    int x, $stack1;\n    java.io.PrintStream $stack2, $stack3;\n\n    x := @parameter0: int;\n\n    $stack1 = x % 2;\n    if $stack1 != 0 goto label1;\n\n    $stack3 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    virtualinvoke $stack3.&lt;java.io.PrintStream: \n      void println(java.lang.String)&gt;(\"Even\");\n    goto label2;\n\n    label1:\n      $stack2 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack2.&lt;java.io.PrintStream: \n        void println(java.lang.String)&gt;(\"Odd\");\n\n    label2:\n      return;\n  }\n}\n/*\n  For statement \"if $stack1 != 0 goto label1;\", \n  we have an instance of JIfStmt :\n    \"if $stack1 != 0 goto $stack2 \n        = &lt;java.lang.System:java.io.PrintStream out&gt;\".\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public static void sampleMethod(int x){\n    if(x % 2 == 0){\n      System.out.println(\"Even\");\n    }else{\n      System.out.println(\"Odd\");\n    }\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x9\npublic static sampleMethod(I)V\n  L0\n    LINENUMBER 5 L0\n    ILOAD 0\n    ICONST_2\n    IREM\n    IFNE L1\n  L2\n    LINENUMBER 6 L2\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Even\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n    GOTO L3\n  L1\n    LINENUMBER 8 L1\n    FRAME SAME\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Odd\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L3\n    LINENUMBER 10 L3\n    FRAME SAME\n    RETURN\n  L4\n    LOCALVARIABLE x I L0 L4 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple-stmts/#jswitchstmt","title":"JSwitchStmt","text":"<p>for conditional flow that behaves like a switch-case. It has #numberOfCaseLabels+1 (for default) successor Stmt's. </p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public void switchExample(int)\n  {\n    int x;\n    java.io.PrintStream $stack2, $stack3, $stack4;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    x := @parameter0: int;\n\n    lookupswitch(x)\n    {\n      case 1: goto label1;\n      case 2: goto label2;\n      default: goto label3;\n    };\n\n    label1:\n      $stack3 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack3.&lt;java.io.PrintStream: \n        void println(java.lang.String)&gt;(\"Input 1\");\n      goto label4;\n\n    label2:\n      $stack2 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack2.&lt;java.io.PrintStream: \n        void println(java.lang.String)&gt;(\"Input 2\");\n      goto label4;\n\n    label3:\n      $stack4 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack4.&lt;java.io.PrintStream: \n        void println(java.lang.String)&gt;(\"Input more than 2\");\n\n    label4:\n      return;\n  }\n}\n/*\n  Here for below statement:\n    lookupswitch(x)\n      {\n        case 1: goto label1;\n        case 2: goto label2;\n        default: goto label3;\n      };\n\n  we have an instance of JLookupSwitchStmt :\n    lookupswitch(x) \n      {     \n        case 1: goto $stack3 \n                        = &lt;java.lang.System: java.io.PrintStream out&gt;;     \n        case 2: goto $stack2 \n                        = &lt;java.lang.System: java.io.PrintStream out&gt;;     \n        default: goto $stack4 \n                        = &lt;java.lang.System: java.io.PrintStream out&gt;; \n      }\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public void switchExample(int x){\n    switch (x){\n      case 1:\n        System.out.println(\"Input 1\");\n        break;\n\n      case 2:\n        System.out.println(\"Input 2\");\n        break;\n\n      default:\n        System.out.println(\"Input more than 2\");\n        break;\n\n    }\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic switchExample(I)V\n  L0\n    LINENUMBER 5 L0\n    ILOAD 1\n    LOOKUPSWITCH\n    1: L1\n    2: L2\n    default: L3\n  L1\n    LINENUMBER 7 L1\n    FRAME SAME\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Input 1\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L4\n    LINENUMBER 8 L4\n    GOTO L5\n  L2\n    LINENUMBER 11 L2\n    FRAME SAME\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Input 2\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L6\n    LINENUMBER 12 L6\n    GOTO L5\n  L3\n    LINENUMBER 15 L3\n    FRAME SAME\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Input more than 2\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L5\n    LINENUMBER 19 L5\n    FRAME SAME\n    RETURN\n  L7\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L7 0\n    LOCALVARIABLE x I L0 L7 1\n    MAXSTACK = 2\n    MAXLOCALS = 2\n}\n</code></pre>"},{"location":"jimple-stmts/#fallsthrough-stmts","title":"FallsThrough Stmts","text":"<p>The execution of a FallsthroughStmt goes on with the following Stmt (if no exception was thrown). </p>"},{"location":"jimple-stmts/#jinvokestmt","title":"JInvokeStmt","text":"<p>transfers the control flow to another method until the called method returns.  </p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public void print(int)\n  {\n    target.exercise1.DemoClass this;\n    int x, a;\n    java.io.PrintStream $stack4, $stack6;\n\n    this := @this: target.exercise1.DemoClass;\n    x := @parameter0: int;\n\n    a = virtualinvoke this.&lt;target.exercise1.DemoClass: int increment(int)&gt;(x);\n    $stack4 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    virtualinvoke $stack4.&lt;java.io.PrintStream: void println(int)&gt;(a);\n\n    a = virtualinvoke this.&lt;target.exercise1.DemoClass: int increment(int)&gt;(a);\n    $stack6 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    virtualinvoke $stack6.&lt;java.io.PrintStream: void println(int)&gt;(a);\n\n    return;\n  }\n\n  public int increment(int)\n  {\n    int x, $stack2;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    x := @parameter0: int;\n\n    $stack2 = x + 1;\n    return $stack2;\n  }\n}\n/*\n  \"specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;()\", \n  \"virtualinvoke this.&lt;target.exercise1.DemoClass: int increment(int)&gt;(x)\", \n  \"virtualinvoke this.&lt;target.exercise1.DemoClass: int increment(int)&gt;(a)\" \n    are JInvokeStmts.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public void print(int x){\n    int a = increment(x);\n    System.out.println(a);\n    a = increment(a);\n    System.out.println(a);\n  }\n  public int increment(int x){\n    return x + 1;\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic print(I)V\n  L0\n    LINENUMBER 5 L0\n    ALOAD 0\n    ILOAD 1\n    INVOKEVIRTUAL target/exercise1/DemoClass.increment (I)I\n    ISTORE 2\n  L1\n    LINENUMBER 6 L1\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 2\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L2\n    LINENUMBER 7 L2\n    ALOAD 0\n    ILOAD 2\n    INVOKEVIRTUAL target/exercise1/DemoClass.increment (I)I\n    ISTORE 2\n  L3\n    LINENUMBER 8 L3\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 2\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L4\n    LINENUMBER 9 L4\n    RETURN\n  L5\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L5 0\n    LOCALVARIABLE x I L0 L5 1\n    LOCALVARIABLE a I L1 L5 2\n    MAXSTACK = 2\n    MAXLOCALS = 3\n\n// access flags 0x1\npublic increment(I)I\n  L0\n    LINENUMBER 11 L0\n    ILOAD 1\n    ICONST_1\n    IADD\n    IRETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    LOCALVARIABLE x I L0 L1 1\n    MAXSTACK = 2\n    MAXLOCALS = 2\n}\n</code></pre>"},{"location":"jimple-stmts/#jassignstmt","title":"JAssignStmt","text":"<p>assigns a Value from the right hand-side to the left hand-side. Left hand-side of an assignment can be a Local referencing a variable (i.e. a Local) or a FieldRef referencing a Field. Right hand-side of an assignment can be an expression (Expr), a Local, a FieldRef or a Constant.  </p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    this.&lt;target.exercise1.DemoClass: int counter&gt; = 0;\n    return;\n  }\n\n  public int updateCounter()\n  {\n    target.exercise1.DemoClass this;\n    int $stack1, $stack2, $stack3;\n\n    this := @this: target.exercise1.DemoClass;\n\n    $stack1 = this.&lt;target.exercise1.DemoClass: int counter&gt;;\n    $stack2 = $stack1 + 1;\n    this.&lt;target.exercise1.DemoClass: int counter&gt; = $stack2;\n    $stack3 = this.&lt;target.exercise1.DemoClass: int counter&gt;;\n\n    return $stack3;\n  }\n}\n/*\n  \"this.&lt;target.exercise1.DemoClass: int counter&gt; = 0\", \n  \"$stack1 = this.&lt;target.exercise1.DemoClass: int counter&gt;\",\n  \"$stack2 = $stack1 + 1\"\n  \"this.&lt;target.exercise1.DemoClass: int counter&gt; = $stack2\"\n  \"$stack3 = this.&lt;target.exercise1.DemoClass: int counter&gt;\"\n    are JAssignStmts.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  private int counter = 0;\n  public int updateCounter(){\n    counter = counter + 1;\n    return counter;\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x2\nprivate I counter\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n  L1\n    LINENUMBER 4 L1\n    ALOAD 0\n    ICONST_0\n    PUTFIELD target/exercise1/DemoClass.counter : I\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic updateCounter()I\n  L0\n    LINENUMBER 6 L0\n    ALOAD 0\n    ALOAD 0\n    GETFIELD target/exercise1/DemoClass.counter : I\n    ICONST_1\n    IADD\n    PUTFIELD target/exercise1/DemoClass.counter : I\n  L1\n    LINENUMBER 7 L1\n    ALOAD 0\n    GETFIELD target/exercise1/DemoClass.counter : I\n    IRETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 3\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple-stmts/#jidentitystmt","title":"JIdentityStmt","text":"<p>is similar to the <code>JAssignStmt</code> and but handles assignments of <code>IdentityRef</code>s to make implicit assignments explicit into the <code>StmtGraph</code>.</p> <ul> <li>Assigns parameters to a <code>Local</code> via <code>JParameterRef</code> like <code>@parameter0: int</code> refering to the first argument of the method (which is of Type int in this case).</li> <li>Assigns exceptions to a <code>Local</code> via <code>JCaughtExceptionRef</code> like <code>@caughtexception: java.lang.NullpointerException</code></li> <li>Assigns the <code>this</code> Variable to a <code>Local</code> via a <code>JThisRef</code></li> </ul> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public void DemoClass(int)\n  {\n    target.exercise1.DemoClass this;\n    int counter;\n\n    this := @this: target.exercise1.DemoClass;\n    counter := @parameter0: int;\n    this.&lt;target.exercise1.DemoClass: int counter&gt; = counter;\n    return;\n  }\n}\n/*\n  \"this := @this: target.exercise1.DemoClass\" and \n    \"counter := @parameter0: int\" are JIdentityStmts\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  private int counter;\n  public void DemoClass(int counter){\n    this.counter = counter;\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x2\nprivate I counter\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic DemoClass(I)V\n  L0\n    LINENUMBER 6 L0\n    ALOAD 0\n    ILOAD 1\n    PUTFIELD target/exercise1/DemoClass.counter : I\n  L1\n    LINENUMBER 7 L1\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    LOCALVARIABLE counter I L0 L2 1\n    MAXSTACK = 2\n    MAXLOCALS = 2\n}\n</code></pre>"},{"location":"jimple-stmts/#jentermonitorstmt-jexitmonitorstmt","title":"JEnterMonitorStmt &amp; JExitMonitorStmt","text":"<p>marks synchronized blocks of code from JEnterMonitorStmt to JExitMonitorStmt.  </p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    this.&lt;target.exercise1.DemoClass: int counter&gt; = 0;\n    return;\n  }\n\n  public int updateCounter()\n  {\n    target.exercise1.DemoClass this;\n    int $stack4, $stack5, $stack7;\n    java.lang.Throwable $stack8;\n\n    this := @this: target.exercise1.DemoClass;\n\n    entermonitor this;\n\n    label1:\n      $stack4 = this.&lt;target.exercise1.DemoClass: int counter&gt;;\n      $stack5 = $stack4 + 1;\n      this.&lt;target.exercise1.DemoClass: int counter&gt; = $stack5;\n\n      exitmonitor this;\n\n    label2:\n      goto label5;\n\n    label3:\n      $stack8 := @caughtexception;\n\n      exitmonitor this;\n\n    label4:\n      throw $stack8;\n\n    label5:\n      $stack7 = this.&lt;target.exercise1.DemoClass: int counter&gt;;\n      return $stack7;\n\n      catch java.lang.Throwable from label1 to label2 with label3;\n      catch java.lang.Throwable from label3 to label4 with label3;\n  }\n}\n/*\n  \"entermonitor this\" is JEnterMonitorStmt.\n  \"exitmonitor this\" is JExitMonitorStmt.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  private int counter = 0;\n  public int updateCounter(){\n    synchronized (this) {\n      counter = counter + 1;\n    }\n    return counter;\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x2\nprivate I counter\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n  L1\n    LINENUMBER 4 L1\n    ALOAD 0\n    ICONST_0\n    PUTFIELD target/exercise1/DemoClass.counter : I\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic updateCounter()I\n    TRYCATCHBLOCK L0 L1 L2 null\n    TRYCATCHBLOCK L2 L3 L2 null\n  L4\n    LINENUMBER 6 L4\n    ALOAD 0\n    DUP\n    ASTORE 1\n    MONITORENTER\n  L0\n    LINENUMBER 7 L0\n    ALOAD 0\n    ALOAD 0\n    GETFIELD target/exercise1/DemoClass.counter : I\n    ICONST_1\n    IADD\n    PUTFIELD target/exercise1/DemoClass.counter : I\n  L5\n    LINENUMBER 8 L5\n    ALOAD 1\n    MONITOREXIT\n  L1\n    GOTO L6\n  L2\n    FRAME FULL [target/exercise1/DemoClass java/lang/Object] \n      [java/lang/Throwable]\n    ASTORE 2\n    ALOAD 1\n    MONITOREXIT\n  L3\n    ALOAD 2\n    ATHROW\n  L6\n    LINENUMBER 9 L6\n    FRAME CHOP 1\n    ALOAD 0\n    GETFIELD target/exercise1/DemoClass.counter : I\n    IRETURN\n  L7\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L4 L7 0\n    MAXSTACK = 3\n    MAXLOCALS = 3\n}\n</code></pre>"},{"location":"jimple-stmts/#jretstmt","title":"JRetStmt","text":"<p>// TODO: java 1.6 spec</p>"},{"location":"jimple-stmts/#jbreakpointstmt","title":"JBreakpointStmt","text":"<p>models a Breakpoint set by a Debugger. Therefore, not really relevant for static analyses but useful for code generation.</p>"},{"location":"jimple-stmts/#other-stmts","title":"Other Stmts","text":""},{"location":"jimple-stmts/#jreturnstmt-jreturnvoidstmt","title":"JReturnStmt &amp; JReturnVoidStmt","text":"<p>They end the execution/flow inside the current method and return (a value) to its caller.</p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public int increment(int)\n  {\n    int x, $stack2;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    x := @parameter0: int;\n\n    $stack2 = x + 1;\n    return $stack2;\n  }\n\n  public void print()\n  {\n    java.io.PrintStream $stack1;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    $stack1 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    virtualinvoke $stack1.&lt;java.io.PrintStream: \n      void println(java.lang.String)&gt;(\"Inside method print\");\n    return;\n  }\n}\n/*\n  \"return $stack2\" is JReturnStmt.\n  \"return\" is JReturnVoidStmt.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public int increment(int x){\n    return x + 1;\n  }\n  public void print(){\n    System.out.println(\"Inside method print\");\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic increment(I)I\n  L0\n    LINENUMBER 5 L0\n    ILOAD 1\n    ICONST_1\n    IADD\n    IRETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    LOCALVARIABLE x I L0 L1 1\n    MAXSTACK = 2\n    MAXLOCALS = 2\n\n// access flags 0x1\npublic print()V\n  L0\n    LINENUMBER 8 L0\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Inside method print\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L1\n    LINENUMBER 9 L1\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple-stmts/#jthrowstmt","title":"JThrowStmt","text":"<p>Ends the execution inside the current Method if the thrown exception is not caught by a Trap, which redirects the execution to an exceptionhandler.</p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public void divideExample(int, int)\n  {\n    int y, x, $stack6;\n    java.lang.StringBuilder $stack3, $stack5, $stack7;\n    java.io.PrintStream $stack4;\n    java.lang.String $stack8;\n    java.lang.RuntimeException $stack9;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    x := @parameter0: int;\n    y := @parameter1: int;\n\n    if y != 0 goto label1;\n\n    $stack9 = new java.lang.RuntimeException;\n    specialinvoke $stack9.&lt;java.lang.RuntimeException: \n      void &lt;init&gt;(java.lang.String)&gt;(\"Divide by zero error\");\n    throw $stack9;\n\n    label1:\n      $stack4 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack3 = new java.lang.StringBuilder;\n      specialinvoke $stack3.&lt;java.lang.StringBuilder: void &lt;init&gt;()&gt;();\n\n      $stack5 = virtualinvoke $stack3.&lt;java.lang.StringBuilder: \n        java.lang.StringBuilder append(java.lang.String)&gt;(\"Divide result : \");\n      $stack6 = x / y;\n      $stack7 = virtualinvoke $stack5.&lt;java.lang.StringBuilder: \n        java.lang.StringBuilder append(int)&gt;($stack6);\n      $stack8 = virtualinvoke $stack7.&lt;java.lang.StringBuilder: \n        java.lang.String toString()&gt;();\n\n      virtualinvoke $stack4.&lt;java.io.PrintStream: \n        void println(java.lang.String)&gt;($stack8);\n      return;\n  }\n}\n/*\n  \"throw $stack9\" is JThrowStmt.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public void divideExample(int x, int y){\n    if(y == 0){\n      throw new RuntimeException(\"Divide by zero error\");\n    }\n    System.out.println(\"Divide result : \" + x / y);\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic divideExample(II)V\n  L0\n    LINENUMBER 5 L0\n    ILOAD 2\n    IFNE L1\n  L2\n    LINENUMBER 6 L2\n    NEW java/lang/RuntimeException\n    DUP\n    LDC \"Divide by zero error\"\n    INVOKESPECIAL java/lang/RuntimeException.&lt;init&gt; \n      (Ljava/lang/String;)V\n    ATHROW\n  L1\n    LINENUMBER 8 L1\n    FRAME SAME\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    NEW java/lang/StringBuilder\n    DUP\n    INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V\n    LDC \"Divide result : \"\n    INVOKEVIRTUAL java/lang/StringBuilder.append \n      (Ljava/lang/String;)Ljava/lang/StringBuilder;\n    ILOAD 1\n    ILOAD 2\n    IDIV\n    INVOKEVIRTUAL java/lang/StringBuilder.append \n      (I)Ljava/lang/StringBuilder;\n    INVOKEVIRTUAL java/lang/StringBuilder.toString \n      ()Ljava/lang/String;\n    INVOKEVIRTUAL java/io/PrintStream.println \n      (Ljava/lang/String;)V\n  L3\n    LINENUMBER 9 L3\n    RETURN\n  L4\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L4 0\n    LOCALVARIABLE x I L0 L4 1\n    LOCALVARIABLE y I L0 L4 2\n    MAXSTACK = 4\n    MAXLOCALS = 3\n}\n</code></pre>"},{"location":"jimple-stmts/#good-to-know","title":"Good to know","text":"<p>A lot of the SootUp APIs return the <code>Stmt</code> Interface. To determine and handle its subtypes you can make use of instanceof.</p> instanceOf &amp; If-Else <pre><code>    List&lt;Stmt&gt; stmts = ... ;\n    for( Stmt stms : stmts ){\n        if(stmt instanceof JAssignStmt){\n            // found a JAssignStmt\n            Value rhsOp = ((JAssignStmt) stmt).getRightOp();\n            ...\n        }else if(stmt instanceof JInvokeStmt){\n            // found a JInvokeStmt\n            JInvokeStmt ivkStmt = ((JInvokeStmt) stmt);\n            MethodSignature rhsOp = ivkStmt.getInvokeExpr().getMethodSignature();\n                ...\n        }else ...\n    }\n</code></pre> <p>But this could escalate to a huge if-else-tree - almost a forest. To mitigate such scenario you can implement a subclass of <code>AbstractStmtVisitor</code>. Just subclass the methods to the respective Stmts you need to handle. This is visitor acts like a switch-case, implemented via two dynamic calls.</p> StmtVisitor <pre><code>    List&lt;Stmt&gt; stmts = ...;\n    AbstractStmtVisitor visitor = new AbstractStmtVisitor&lt;Integer&gt;() {\n        private int ifStmtsCounter = 0;\n        @Override\n        public void caseIfStmt(@Nonnull JIfStmt stmt) {\n            ifStmtsCounter++;\n            setResult(ifStmtCounter);\n        }\n    };\n\n    for( Stmt stms : stmts ){\n        stmt.accept(visitor);\n    }\n\n    int amountOfIfStmts = visitor.getResult();\n</code></pre> <p>Sidenote: Of course its possible can create a subclass instead of an anonymous class.</p>"},{"location":"jimple-types/","title":"Jimple Types","text":"<p>represents primary types i.e. non-reference types and non-void</p>"},{"location":"jimple-types/#primarytype","title":"PrimaryType","text":"<ul> <li><code>BooleanType</code></li> <li><code>ByteType</code></li> <li><code>CharType</code></li> <li><code>ShortType</code></li> <li><code>IntType</code></li> <li><code>LongType</code></li> <li><code>DoubleType</code></li> <li><code>FloatType</code></li> </ul> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n      target.exercise1.DemoClass this;\n      this := @this: target.exercise1.DemoClass;\n      specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n      return;\n  }\n\n\n  public void display()\n  {\n      java.io.PrintStream $stack11, $stack13, $stack15, \n        $stack17, $stack19, $stack21, $stack23, $stack25;\n      int $stack12, $stack14, $stack16, $stack18;\n      long $stack20;\n      double $stack22;\n      float $stack24;\n      target.exercise1.DemoClass this;\n      boolean $stack26;\n\n      this := @this: target.exercise1.DemoClass;\n\n      $stack11 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n\n      goto label1;\n\n   label1:\n      $stack26 = 0;\n      virtualinvoke $stack11.&lt;java.io.PrintStream: \n        void println(boolean)&gt;($stack26);\n\n      $stack13 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack12 = 127 - 1;\n      virtualinvoke $stack13.&lt;java.io.PrintStream: \n        void println(int)&gt;($stack12);\n\n      $stack15 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack14 = 97 + 1;\n      virtualinvoke $stack15.&lt;java.io.PrintStream: \n        void println(int)&gt;($stack14);\n\n      $stack17 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack16 = 1123 + 1;\n      virtualinvoke $stack17.&lt;java.io.PrintStream: \n        void println(int)&gt;($stack16);\n\n      $stack19 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack18 = 123456 + 1;\n      virtualinvoke $stack19.&lt;java.io.PrintStream: \n        void println(int)&gt;($stack18);\n\n      $stack21 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack20 = 10L + 1L;\n      virtualinvoke $stack21.&lt;java.io.PrintStream: \n        void println(long)&gt;($stack20);\n\n      $stack23 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack22 = 10.1 + 1.0;\n      virtualinvoke $stack23.&lt;java.io.PrintStream: \n        void println(double)&gt;($stack22);\n\n      $stack25 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      $stack24 = 10.1F + 1.0F;\n      virtualinvoke $stack25.&lt;java.io.PrintStream: \n        void println(float)&gt;($stack24);\n\n      return;\n  }\n}\n/*\n  The JimpleLocal $stack12, $stack14, $stack16, $stack18 are of IntType. \n  Similarly, $stack20 is of LongType, $stack22 is of DoubleType and so on.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public void display(){\n    boolean varBoolean = true;\n    byte varByte = 127;\n    char varChar = 'a';\n    short varShort = 1123;\n    int varInt = 123456;\n    long varLong = 10L;\n    double varDouble = 10.10;\n    float varFloat = 10.10f;\n\n    System.out.println(!varBoolean);\n    System.out.println(varByte-1);\n    System.out.println(varChar+1);\n    System.out.println(varShort+1);\n    System.out.println(varInt+1);\n    System.out.println(varLong+1);\n    System.out.println(varDouble+1);\n    System.out.println(varFloat+1);\n\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic display()V\n  L0\n    LINENUMBER 5 L0\n    ICONST_1\n    ISTORE 1\n  L1\n    LINENUMBER 6 L1\n    BIPUSH 127\n    ISTORE 2\n  L2\n    LINENUMBER 7 L2\n    BIPUSH 97\n    ISTORE 3\n  L3\n    LINENUMBER 8 L3\n    SIPUSH 1123\n    ISTORE 4\n  L4\n    LINENUMBER 9 L4\n    LDC 123456\n    ISTORE 5\n  L5\n    LINENUMBER 10 L5\n    LDC 10\n    LSTORE 6\n  L6\n    LINENUMBER 11 L6\n    LDC 10.1\n    DSTORE 8\n  L7\n    LINENUMBER 12 L7\n    LDC 10.1\n    FSTORE 10\n  L8\n    LINENUMBER 14 L8\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 1\n    IFNE L9\n    ICONST_1\n    GOTO L10\n  L9\n    FRAME FULL [target/exercise1/DemoClass I I I I I J D F] \n      [java/io/PrintStream]\n    ICONST_0\n  L10\n    FRAME FULL [target/exercise1/DemoClass I I I I I J D F] \n      [java/io/PrintStream I]\n    INVOKEVIRTUAL java/io/PrintStream.println (Z)V\n  L11\n    LINENUMBER 15 L11\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 2\n    ICONST_1\n    ISUB\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L12\n    LINENUMBER 16 L12\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 3\n    ICONST_1\n    IADD\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L13\n    LINENUMBER 17 L13\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 4\n    ICONST_1\n    IADD\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L14\n    LINENUMBER 18 L14\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 5\n    ICONST_1\n    IADD\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L15\n    LINENUMBER 19 L15\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LLOAD 6\n    LCONST_1\n    LADD\n    INVOKEVIRTUAL java/io/PrintStream.println (J)V\n  L16\n    LINENUMBER 20 L16\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    DLOAD 8\n    DCONST_1\n    DADD\n    INVOKEVIRTUAL java/io/PrintStream.println (D)V\n  L17\n    LINENUMBER 21 L17\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    FLOAD 10\n    FCONST_1\n    FADD\n    INVOKEVIRTUAL java/io/PrintStream.println (F)V\n  L18\n    LINENUMBER 23 L18\n    RETURN\n  L19\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L19 0\n    LOCALVARIABLE varBoolean Z L1 L19 1\n    LOCALVARIABLE varByte B L2 L19 2\n    LOCALVARIABLE varChar C L3 L19 3\n    LOCALVARIABLE varShort S L4 L19 4\n    LOCALVARIABLE varInt I L5 L19 5\n    LOCALVARIABLE varLong J L6 L19 6\n    LOCALVARIABLE varDouble D L7 L19 8\n    LOCALVARIABLE varFloat F L8 L19 10\n    MAXSTACK = 5\n    MAXLOCALS = 11\n}\n</code></pre>"},{"location":"jimple-types/#referencetype","title":"ReferenceType","text":"<ul> <li><code>(Java)ClassType</code> - represents the type of a Class.</li> <li><code>ArrayType</code> - represents an array.</li> <li><code>NullType</code> - assignable to one of the other ReferenceTypes.</li> </ul> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\npublic void &lt;init&gt;()\n  {\n  target.exercise1.DemoClass this;\n  this := @this: target.exercise1.DemoClass;\n  specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n  return;\n  }\n\n  public target.exercise1.DemoClass getObject(target.exercise1.DemoClass)\n  {\n  target.exercise1.DemoClass obj, this;\n  this := @this: target.exercise1.DemoClass;\n  obj := @parameter0: target.exercise1.DemoClass;\n  return obj;\n  }\n\n  public void compute(boolean)\n  {\n  int[] b;\n  java.io.PrintStream $stack5, $stack6;\n  boolean check;\n  target.exercise1.DemoClass this;\n  int i;\n  null_type r0;\n  java.lang.NullPointerException soot0;\n  this := @this: target.exercise1.DemoClass;\n  check := @parameter0: boolean;\n  b = newarray (int)[5];\n  i = 0;\n\n  label1:\n    if i &gt;= 5 goto label3;\n      if check == 0 goto label2;\n      r0 = (null_type) i;\n      soot0 = new java.lang.NullPointerException;\n      specialinvoke soot0.&lt;java.lang.NullPointerException: \n        void &lt;init&gt;(java.lang.String)&gt;\n          (\"This statement would have triggered an Exception: a[i#1] = r0\");\n      throw soot0;\n\n  label2:\n  b[i] = i;\n      i = i + 1;\n      goto label1;\n\n  label3:\n      $stack5 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack5.&lt;java.io.PrintStream: \n        void println(java.lang.Object)&gt;(b);\n      $stack6 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n      virtualinvoke $stack6.&lt;java.io.PrintStream: \n        void println(java.lang.Object)&gt;(null);\n      return;\n  }\n}\n/*\n  The Local b is of ArrayType,\n    and Local r0 is of NullType.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n\n  public DemoClass getObject(DemoClass obj){\n    return obj;\n  }\n\n  public void compute(boolean check){\n    int a[] = null;\n    int b[] = new int[5];\n    for (int i = 0; i &lt; 5; i++) {\n      if(check){\n        a[i] = i;\n      }\n        b[i] = i;\n    }\n    System.out.println(b);\n    System.out.println(a);\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic getObject(Ltarget/exercise1/DemoClass;)Ltarget/exercise1/DemoClass;\n  L0\n    LINENUMBER 6 L0\n    ALOAD 1\n    ARETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    LOCALVARIABLE obj Ltarget/exercise1/DemoClass; L0 L1 1\n    MAXSTACK = 1\n    MAXLOCALS = 2\n\n// access flags 0x1\npublic compute(Z)V\n  L0\n    LINENUMBER 10 L0\n    ACONST_NULL\n    ASTORE 2\n  L1\n    LINENUMBER 11 L1\n    ICONST_5\n    NEWARRAY T_INT\n    ASTORE 3\n  L2\n    LINENUMBER 12 L2\n    ICONST_0\n    ISTORE 4\n  L3\n    FRAME APPEND [[I [I I]\n    ILOAD 4\n    ICONST_5\n    IF_ICMPGE L4\n  L5\n    LINENUMBER 13 L5\n    ILOAD 1\n    IFEQ L6\n  L7\n    LINENUMBER 14 L7\n    ALOAD 2\n    ILOAD 4\n    ILOAD 4\n    IASTORE\n  L6\n    LINENUMBER 16 L6\n    FRAME SAME\n    ALOAD 3\n    ILOAD 4\n    ILOAD 4\n    IASTORE\n  L8\n    LINENUMBER 12 L8\n    IINC 4 1\n    GOTO L3\n  L4\n    LINENUMBER 18 L4\n    FRAME CHOP 1\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ALOAD 3\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V\n  L9\n    LINENUMBER 19 L9\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ALOAD 2\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V\n  L10\n    LINENUMBER 20 L10\n    RETURN\n  L11\n    LOCALVARIABLE i I L3 L4 4\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L11 0\n    LOCALVARIABLE check Z L0 L11 1\n    LOCALVARIABLE a [I L1 L11 2\n    LOCALVARIABLE b [I L2 L11 3\n    MAXSTACK = 3\n    MAXLOCALS = 5\n}\n</code></pre>"},{"location":"jimple-types/#voidtype","title":"VoidType","text":"<p>Used as a possible return type of a method.</p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n  target.exercise1.DemoClass this;\n  this := @this: target.exercise1.DemoClass;\n  specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n  return;\n  }\n\n  public void voidMethod()\n  {\n  java.io.PrintStream $stack1;\n  target.exercise1.DemoClass this;\n  this := @this: target.exercise1.DemoClass;\n  $stack1 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n  virtualinvoke $stack1.&lt;java.io.PrintStream: \n      void println(java.lang.String)&gt;(\"In voidMethod().\");\n  return;\n  }\n}\n/*\n  For the SootMethod - &lt;target.exercise1.DemoClass: void voidMethod()&gt;, \n    returnType is instance of VoidType.\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  public void voidMethod(){\n  System.out.println(\"In voidMethod().\");\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic voidMethod()V\n  L0\n    LINENUMBER 5 L0\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"In voidMethod().\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L1\n    LINENUMBER 6 L1\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple-values/","title":"Jimple Values","text":""},{"location":"jimple-values/#immediate","title":"Immediate","text":"<p>An <code>Immediate</code> has a given Type and consists of a Local (\"a Variable\", \"Something that contains a Value\") or a Constant (\"Something that is a Value\").</p>"},{"location":"jimple-values/#local","title":"Local","text":"<pre><code>i0 \n</code></pre> <p>A Local is a variable and its scope is inside its method i.e. no referencing from outside a method. Values can be assigned to Locals via JIdentityStmt or JAssignStmt.</p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public void compute()\n  {\n    java.io.PrintStream $stack2, $stack3;\n    target.exercise1.DemoClass this;\n    int local2;\n\n    this := @this: target.exercise1.DemoClass;\n    $stack2 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    virtualinvoke $stack2.&lt;java.io.PrintStream: void println(int)&gt;(1);\n\n    local2 = this.&lt;target.exercise1.DemoClass: int global&gt;;\n    $stack3 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    virtualinvoke $stack3.&lt;java.io.PrintStream: void println(int)&gt;(local2);\n    return;\n  }\n}\n/*\n  $stack2, this, $stack3, local2 are all Locals.\n\n  \"this := @this: target.exercise1.DemoClass\" is a JIdentityStmt assigning to a Local.\n\n  \"$stack2 = &lt;java.lang.System: java.io.PrintStream out&gt;\", \n    \"local2 = this.&lt;target.exercise1.DemoClass: int global&gt;\", \n      \"$stack3 = &lt;java.lang.System: java.io.PrintStream out&gt;\" \n        are JAssignStmts assigning to a Local.\n\n*/  \n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n\n  private int global;\n\n  public void compute(){\n    int local;\n    local = 1;\n    System.out.println(local);\n    local = this.global;\n    System.out.println(local);\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x2\nprivate I global\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic compute()V\n  L0\n    LINENUMBER 9 L0\n    ICONST_1\n    ISTORE 1\n  L1\n    LINENUMBER 10 L1\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 1\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L2\n    LINENUMBER 11 L2\n    ALOAD 0\n    GETFIELD target/exercise1/DemoClass.global : I\n    ISTORE 1\n  L3\n    LINENUMBER 12 L3\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    ILOAD 1\n    INVOKEVIRTUAL java/io/PrintStream.println (I)V\n  L4\n    LINENUMBER 14 L4\n    RETURN\n  L5\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L5 0\n    LOCALVARIABLE local I L1 L5 1\n    MAXSTACK = 2\n    MAXLOCALS = 2\n}\n</code></pre>"},{"location":"jimple-values/#constant","title":"Constant","text":"<p>represents an actual value itself like <code>42</code> or <code>\"This is a String\"</code>. Constants are usually assigned to <code>Local</code>s or <code>Ref</code>s. There exists a constant entity for every Primitive Type.</p>"},{"location":"jimple-values/#expr","title":"Expr","text":"<p>An expression is a language construct that calculates an operation and returns a value. E.g. a binary operation <code>AbstracBinopExpr</code> such as an addition <code>a + b</code>, an <code>AbstractInvokeExpr</code> such as <code>virtualinvoke $stack2.&lt;java.io.PrintStream: void println(int)&gt;(1);</code> or an <code>UnaryExpr</code> such as <code>!valid</code>. And a bunch more!</p>"},{"location":"jimple-values/#ref","title":"Ref","text":""},{"location":"jimple-values/#jarrayref","title":"JArrayRef","text":"<p><pre><code>$arr[1] = 42;\n$anotherLocal = arr[99];\n</code></pre> referencing an array position.</p>"},{"location":"jimple-values/#jfieldref","title":"JFieldRef","text":"<p><code>JFieldRef</code>s are referencing a <code>SootField</code> via its FieldSignature</p> <ul> <li><code>JStaticFieldRef</code> like <code>&lt;SomePackage.ExampleClass: fieldname&gt;</code></li> <li><code>JInstanceFieldRef</code> like <code>r1.&lt;SomePackage.ExampleClass: fieldname&gt;</code>   You can see the JInstanceFieldRef has the corresponding Local instance that points to the instance of the object which is holding the field.</li> </ul>"},{"location":"jimple-values/#identityref","title":"IdentityRef","text":"<p>The IdentityRef makes those implicit special value assignments explicit.</p>"},{"location":"jimple-values/#jthisref","title":"JThisRef","text":"<p><pre><code>@this: package.fruit.Banana\n</code></pre> represents the this pointer of the current class.</p>"},{"location":"jimple-values/#jcaughtexceptionref","title":"JCaughtExceptionRef","text":"<p><pre><code>@caughtexception\n</code></pre> represents the value of the thrown exception (caught by this exceptionhandler).</p>"},{"location":"jimple-values/#jparameterref","title":"JParameterRef","text":"<p><pre><code>i0 := @parameter0\ni1 := @parameter1 \n</code></pre> represents a parameter of a method, identified by its index.</p>"},{"location":"jimple-values/#good-to-know","title":"Good to know","text":"<p>A lot of the SootUp APIs return the <code>Value</code> Interface. To determine and handle its subtypes you can make use of instanceof.</p> instanceOf &amp; If-Else <pre><code>    Value op = assignStmt.getRightOp();\n    if(op instanceof Local){\n        // found a Local\n        ...\n    }else if(stmt instanceof Constant){\n        // found a Constant\n        ...\n    }else ...\n</code></pre> <p>But this could escalate to a huge if-else-tree - almost a forest. To mitigate such scenario you can implement a subclass of <code>AbstractValueVisitor</code>. Just subclass the methods to the respective <code>Value</code>s you need to handle. This is visitor acts like a switch-case, implemented via two dynamic calls.</p> StmtVisitor <pre><code>    Value op = assignStmt.getRightOp() ;\n    AbstractValueVisitor visitor = new AbstractValueVisitor&lt;Integer&gt;() {\n        private int intConstantCounter = 0;\n        @Override\n        public void caseConstant(@Nonnull Constant c) {\n            intConstantCounter++;\n            setResult(intConstantCounter);\n        }\n    };\n\n    op.accept(visitor);\n    int amountOfIfStmts = visitor.getResult();\n</code></pre> <p>If you only need a visitor for a subset of Value, you can consider ImmediateVisitor, ConstantVisitor, ExprVisitor, RefVisitor. Sidenote: Of course its possible can create a subclass instead of an anonymous class.</p>"},{"location":"jimple/","title":"Jimple","text":"<p>What is Jimple? Jimple is the intermediate representation IR of Soot, and thus SootUp. Soot's intention is to provide a simplified way to analyze JVM bytecode. JVM bytecode is stack-based, which makes it difficult for program analysis. Java source code, on the other hand, is also not quite suitable for program analysis, due to its nested structures. Therefore, Jimple aims to bring the best of both worlds, a non-stack-based and flat (non-nested) representation. For this purpose Jimple was designed as a representation of JVM bytecode which is human readable.</p> <p>Info</p> <p>To learn more about jimple, refer to the thesis by Raja Vallee-Rai.</p> <p>Lets have a look at the following Jimple code representing Java code of a <code>HelloWorld</code> class.</p> JimpleJavaBytecode <pre><code>public class HelloWorld extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    HelloWorld r0;\n    r0 := @this: HelloWorld;\n    specialinvoke r0.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n\n  public static void main(java.lang.String[])\n  {\n    java.lang.String[] r0;\n    java.io.PrintStream r1;\n\n    r0 := @parameter0: java.lang.String[];\n    r1 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    virtualinvoke r1.&lt;java.io.PrintStream: \n    void println(java.lang.String)&gt;(\"Hello world!\");\n    return;\n  }\n}\n</code></pre> <pre><code>public class HelloWorld {\n\n  public HelloWorld() {\n\n  }\n\n  public static void main(String[] var0) {\n    System.out.println(\"Hello World!\");\n  }\n\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class analysis/HelloWorld {\n\n// compiled from: HelloWorld.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 4 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n  L1\n    LINENUMBER 6 L1\n    RETURN\n  L2\n    LOCALVARIABLE this Lanalysis/HelloWorld; L0 L2 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x9\npublic static main([Ljava/lang/String;)V\n  L0\n    LINENUMBER 9 L0\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Hello World!\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L1\n    LINENUMBER 10 L1\n    RETURN\n  L2\n    LOCALVARIABLE var0 [Ljava/lang/String; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n</code></pre> <p>The Java Sourcecode is the easiest representation - So why all the fuzz and just use that? Sometimes we have no access to the sourcecode but have a binary with the bytecode. For most People reading bytecode is not that intuitive. So SootUp generates Jimple from the bytecode. Jimple is very verbose, but makes everything explicit, that the JVM does implicitly and transforms the stack-machine strategy by a register-machine strategy i.e. Variable (<code>Local</code>) handling .</p>"},{"location":"jimple/#jimple-grammar-structure","title":"Jimple Grammar Structure","text":"<p>Jimple mimics the JVMs class file structure. Therefore it is object oriented. A Single Class (or Interface) per file. Three-Address-Code which means there are no nested expressions. (nested expressions can be modeled via Locals that store intermediate calculation results.)</p>"},{"location":"jimple/#signatures-and-classtypes","title":"Signatures and ClassTypes","text":"<p>Signatures are used to identify Classes,Methods or Fields uniquely/globally. Sidenote: Locals, do not have a signature, since they are referenced within method boundaries.</p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    this.&lt;target.exercise1.DemoClass: double pi&gt; = 3.14;\n    return;\n  }\n\n  public void demoMethod()\n  {\n    java.io.PrintStream $stack3, $stack5;\n    java.lang.StringBuilder $stack4, $stack6, $stack7;\n    java.lang.String $stack8;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    $stack3 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n\n    virtualinvoke $stack3.&lt;java.io.PrintStream: \n      void println(java.lang.String)&gt;(\"pi : 3.14\");\n    $stack5 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n    $stack4 = new java.lang.StringBuilder;\n\n    specialinvoke $stack4.&lt;java.lang.StringBuilder: void &lt;init&gt;()&gt;();\n    $stack6 = virtualinvoke $stack4.&lt;java.lang.StringBuilder: \n      java.lang.StringBuilder append(java.lang.String)&gt;\n        (\"pi : \");\n    $stack7 = virtualinvoke $stack6.&lt;java.lang.StringBuilder: \n      java.lang.StringBuilder append(double)&gt;(3.1415);\n    $stack8 = virtualinvoke $stack7.&lt;java.lang.StringBuilder: \n      java.lang.String toString()&gt;();\n\n    virtualinvoke $stack5.&lt;java.io.PrintStream:     \n      void println(java.lang.String)&gt;($stack8);\n    return;\n  }\n}\n/*\n  For JInstanceFieldRef \"this.&lt;target.exercise1.DemoClass: double pi&gt;\" \n    signature is &lt;target.exercise1.DemoClass: double pi&gt;\n  Similarly, we have other signatures like \n    &lt;java.lang.Object: void &lt;init&gt;()&gt;, \n    &lt;java.io.PrintStream: void println(java.lang.String)&gt; \n    and so on. \n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  private final double pi = 3.14;\n\n  public void demoMethod(){\n    double localPi = 3.1415;\n    System.out.println(\"pi : \" + pi);\n    System.out.println(\"pi : \" + localPi);\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x12\nprivate final D pi = 3.14\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n  L1\n    LINENUMBER 4 L1\n    ALOAD 0\n    LDC 3.14\n    PUTFIELD target/exercise1/DemoClass.pi : D\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 3\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic demoMethod()V\n  L0\n    LINENUMBER 6 L0\n    LDC 3.1415\n    DSTORE 1\n  L1\n    LINENUMBER 7 L1\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"pi : 3.14\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L2\n    LINENUMBER 8 L2\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    NEW java/lang/StringBuilder\n    DUP\n    INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V\n    LDC \"pi : \"\n      INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)\n        Ljava/lang/StringBuilder;\n    DLOAD 1\n    INVOKEVIRTUAL java/lang/StringBuilder.append (D)Ljava/lang/StringBuilder;\n    INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L3\n    LINENUMBER 9 L3\n    RETURN\n  L4\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L4 0\n    LOCALVARIABLE localPi D L1 L4 1\n    MAXSTACK = 4\n    MAXLOCALS = 3\n}\n</code></pre>"},{"location":"jimple/#sootclass","title":"SootClass","text":"<p>A <code>SootClass</code> consists of SootFields and SootMethods. It is referenced by its global identifier the <code>ClassType</code> like <code>java.lang.String</code>.</p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    return;\n  }\n}\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n    RETURN\n  L1\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L1 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple/#sootfield","title":"SootField","text":"<p>A SootField is a piece of memory which can store a value that is accessible according to its visibility modifier. It is referenced by its FieldSignature like <code>&lt;java.lang.String: int hash&gt;</code>.</p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    this.&lt;target.exercise1.DemoClass: double pi&gt; = 3.14;\n    return;\n  }\n}\n/*\n  \"this.&lt;target.exercise1.DemoClass: double pi&gt;\" is JInstanceFieldRef\n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  private final double pi = 3.14;\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x12\nprivate final D pi = 3.14\n\n// access flags 0x1\npublic &lt;init&gt;()V\n  L0\n    LINENUMBER 3 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n  L1\n    LINENUMBER 4 L1\n    ALOAD 0\n    LDC 3.14\n    PUTFIELD target/exercise1/DemoClass.pi : D\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 3\n    MAXLOCALS = 1\n}\n</code></pre>"},{"location":"jimple/#sootmethod-and-its-body","title":"SootMethod and its Body","text":"<p>The interesting part is a method. A method is a \"piece of code\" that can be executed. It is referenced by its MethodSignature like <code>&lt;java.lang.Object: java.lang.String toString()&gt;</code>.</p> JimpleJavaBytecode <pre><code>public class target.exercise1.DemoClass extends java.lang.Object\n{\n  public void &lt;init&gt;()\n  {\n    target.exercise1.DemoClass this;\n    this := @this: target.exercise1.DemoClass;\n    specialinvoke this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();\n    virtualinvoke this.&lt;target.exercise1.DemoClass: \n    void demoMethod()&gt;();\n    return;\n  }\n\n  public void demoMethod()\n  {\n    java.io.PrintStream $stack1;\n    target.exercise1.DemoClass this;\n\n    this := @this: target.exercise1.DemoClass;\n    $stack1 = &lt;java.lang.System: java.io.PrintStream out&gt;;\n\n    virtualinvoke $stack1.&lt;java.io.PrintStream: \n    void println(java.lang.String)&gt;(\"Inside method.\");\n    return;\n  }\n}\n/*\n  \"&lt;target.exercise1.DemoClass: void demoMethod()&gt;\" \n        and \"&lt;target.exercise1.DemoClass: void &lt;init&gt;()&gt;\" \n        are instances of SootMethod \n*/\n</code></pre> <pre><code>package target.exercise1;\n\npublic class DemoClass {\n  DemoClass(){\n    demoMethod();\n  }\n  public void demoMethod(){\n    System.out.println(\"Inside method.\");\n  }\n}\n</code></pre> <pre><code>// class version 52.0 (52)\n// access flags 0x21\npublic class target/exercise1/DemoClass {\n\n// compiled from: DemoClass.java\n\n// access flags 0x0\n&lt;init&gt;()V\n  L0\n    LINENUMBER 5 L0\n    ALOAD 0\n    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V\n  L1\n    LINENUMBER 6 L1\n    ALOAD 0\n    INVOKEVIRTUAL target/exercise1/DemoClass.demoMethod ()V\n  L2\n    LINENUMBER 7 L2\n    RETURN\n  L3\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L3 0\n    MAXSTACK = 1\n    MAXLOCALS = 1\n\n// access flags 0x1\npublic demoMethod()V\n  L0\n    LINENUMBER 10 L0\n    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;\n    LDC \"Inside method.\"\n    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V\n  L1\n    LINENUMBER 11 L1\n    RETURN\n  L2\n    LOCALVARIABLE this Ltarget/exercise1/DemoClass; L0 L2 0\n    MAXSTACK = 2\n    MAXLOCALS = 1\n}\n</code></pre> <p>More about the Body of the SootMethod.</p>"},{"location":"migrating/","title":"Migration Help","text":""},{"location":"migrating/#version-130","title":"Version 1.3.0","text":"<ul> <li>The Typehierarchy API is now returning <code>Stream&lt;ClassType&gt;</code> instead of <code>Collection&lt;ClassType&gt;</code>. The simplest fix to have the same behaviour as before would be to collect the Stream on your own ( e.g. via <code>.collect(Collectors.toList())</code> ).</li> <li>Default BytecodeBodyinterceptors are enabled to improve Jimple. To mitigate that adapt the List of BodyInterceptors to your needs.</li> </ul>"},{"location":"migrating/#version-120","title":"Version 1.2.0","text":"<ul> <li>The (Java)Project structure was removed. You can configure the (Java)View directly.</li> <li>Bodyinterceptors are now passed as arguments into AnalysisInputLocations.</li> </ul>"},{"location":"migrating/#from-soot","title":"From Soot","text":"<ul> <li>The Scene singleton is dead. Long live the Scene. We have a central View object(!) now.</li> <li>Library first! No command line tool as primary goal. So you can configure parts of SootUp (near) where it is actually used. </li> <li>t.b.c.</li> </ul> <p>Below we show a comparison of the code so far with the same functionality in sootup.</p> SootUpSoot <pre><code>AnalysisInputLocation&lt;JavaSootClass&gt; inputLocation =\nnew JavaClassPathAnalysisInputLocation(\"path2Binary\");\n\nJavaView view = new JavaView(inputLocation);\n\nJavaClassType classType = \n        view.getIdentifierFactory().getClassType(\"HelloWorld\");\n\nMethodSignature methodSignature =\n    view\n        .getIdentifierFactory()\n        .getMethodSignature(\n            \"main\", classType, \"void\",\n            Collections.singletonList(\"java.lang.String[]\"));\n\nJavaSootClass sootClass = view.getClass(classType).get();\n\nMethodSubSignature mss = methodSignature.getSubSignature();\nJavaSootMethod sootMethod =  sootClass.getMethod(mss).get();\n\nsootMethod.getBody().getStmts();\n</code></pre> <pre><code>G.reset();\nString userdir = System.getProperty(\"user.dir\");\nString sootCp = \n        userdir \n        + File.separator \n        + \"target\" \n        + File.separator \n        + \"test-classes\"\n        + File.pathSeparator + \"lib\"+File.separator+\"rt.jar\";\n\nOptions.v().set_soot_classpath(sootCp);\nOptions.v().set_whole_program(true);\nOptions.v().setPhaseOption(\"cg.cha\", \"on\");\nOptions.v().setPhaseOption(\"cg\", \"all-reachable:true\");\nOptions.v().set_no_bodies_for_excluded(true);\nOptions.v().set_allow_phantom_refs(true);\nOptions.v().setPhaseOption(\"jb\", \"use-original-names:true\");\nOptions.v().set_prepend_classpath(false);\n\nScene.v().addBasicClass(\"java.lang.StringBuilder\");\nSootClass c = \n    Scene.v().forceResolve(targetTestClassName, SootClass.BODIES);\nif (c != null) {\n    c.setApplicationClass();\n}\nScene.v().loadNecessaryClasses();\n\nSootMethod method;\nfor (SootClass c : Scene.v().getApplicationClasses()) {\n    if(c.getName().equals(\"example.HelloWorld\")){\n        for (SootMethod m : c.getMethods()) {\n            if (!m.hasActiveBody()) {\n                continue;\n            }\n            if (m.getName().equals(\"entryPoint\")) {\n                method = m;\n                break;\n            }\n        }\n    }\n}\n\nmethod.getActiveBody().getUnits();\n</code></pre>"},{"location":"qilin/","title":"Incorporate Qilin Pointer Analysis","text":""},{"location":"qilin/#dependencies","title":"Dependencies","text":"MavenGradle <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n    &lt;artifactId&gt;sootup.java.sourcecode&lt;/artifactId&gt;\n    &lt;version&gt;1.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>compile \"org.soot-oss:sootup.qilin:1.3.0\"\n</code></pre>"},{"location":"qilin/#how-to-create-a-pointer-analysis","title":"How to create a pointer analysis","text":"<p>WIP: Beware most likely the API will change so you only need to specify SootUp objects!</p> <p>One can create an Andersen's context-insensitive analysis with following code:</p> Java <pre><code>String entrypoint = \"dacapo.antlr.Main\";\nPTAPattern ptaPattern = new PTAPattern(\"insens\");\nPTA pta = PTAFactory.createPTA(ptaPattern, view, entrypoint);\npta.run();\n</code></pre> <p>Users must specify the program's <code>View</code>, select a <code>PTAPattern</code> (indicating the desired types of pointer analyses to perform), and designate the <code>entrypoint</code> - which is serving as the entry point for the analysis.</p>"},{"location":"qilin/#how-to-use-pointer-analysis-results","title":"How to use pointer analysis results","text":"<p>First, we can use Qilin's pointer analysis to get a On-the-Fly constructed callgraph:</p> <pre><code>OnFlyCallGraph cg = pta.getCallGraph();\n</code></pre> <p>Second, we can use it to get the points-to results for some interested local variables, fields, etc.</p> <pre><code>PointsToSet pts0 = pta.reachingObjects(method, v0);\nPointsToSet pts1 = pta.reachingObjects(method, v1, f); // PTS(v1.f)\n</code></pre> <p>Third, we can check whether two variables, <code>a</code> and <code>b</code>, are aliases by checking whether there is an object that exists in both of their points-to sets.</p> <p>Qilin does not currently offer a <code>isMayAlias</code> API within the PTA class. However, a similar functionality can be found in <code>qilin.test.util.AliasAssertion</code> with the method: <code>boolean isMayAlias(PTA pta, Value va, Value vb)</code> This method allows to check for potential aliasing between two values given a PTA instance.</p>"},{"location":"qilin/#a-full-list-of-pointer-analyses","title":"A Full list of Pointer Analyses","text":"<p>Qilin's toolbox includes a rich set of pointer analyses, which are given below:</p> <p>Note that the symbol k used in the table should be replaced with a concrete small constant like 1 or 2.</p> PTA patterns Description Reference insens Andersen's context-insensitive analysis Paper kc k-callsite-sensitive pointer analysis (denoted kCFA). Paper ko k-object-sensitive pointer analysis (denoted kOBJ). Paper kt k-type-sensitive pointer analysis (denoted kTYPE). Paper kh hybrid k-object-sensitive pointer analysis. Paper kht hybrid k-type-sensitive pointer analysis. Paper B-2o BEAN-guided 2OBJ. Only k=2 is supported. Paper D-2o Data-driven 2OBJ. Only k=2 is supported. Paper D-2c Data-driven 2CFA. Only k=2 is supported. Paper M-ko MAHJONG-guided kOBJ. Paper M-kc MAHJONG-guided kCFA. Paper E-ko EAGLE-guided kOBJ. Paper T-ko TURNER-guided kOBJ. Paper Z-ko ZIPPER-guided kOBJ. Paper Z-kc ZIPPER-guided kCFA. Paper Z-ko -cd The context debloated version of ZIPPER-guided kOBJ. Paper ko -cd -cda=CONCH The context debloated version of kOBJ using Conch. Paper ko -cd -cda=DEBLOATERX The context debloated version of kOBJ using DebloaterX. Paper s-kc SELECTX-guided kCFA. Paper"},{"location":"tool_setup/","title":"From Prototype to an intuitive Tool","text":"<p>How was the parameter order again? For a lot of cli tools we see an arbitrary order of cli parameters, different options for giving a working directory etc.. So in the wild you can see a lot from run.sh/run.bat to make files just to reorder arguments to execute a tool.</p> <p>In SootUp we thought we could help on improving this madness while saving your time.</p> <p>The command line parser mimics the options the java executable accepts - at least for what is supported by SootUp. This makes it very simple to just copy the execution paramaters you use for execution, to use them more or less as is four the analysis tool.</p>"},{"location":"tool_setup/#dependencies","title":"Dependencies","text":"MavenGradle <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;commons-cli&lt;/groupId&gt;\n    &lt;artifactId&gt;commons-cli&lt;/artifactId&gt;\n    &lt;version&gt;1.8.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>    implementation(\"commons-cli:commons-cli:1.8.0\")\n</code></pre>"},{"location":"tool_setup/#java-code","title":"Java Code","text":"<pre><code>```java\n\nclass SootUpConfiguration{\n    // TODO incorporate from downstream\n}\n\n```\n</code></pre> <p>We are happy if you steal the following code to create a tool where the setup is just simple.</p>"},{"location":"tools/","title":"Who uses SootUp","text":"<ul> <li>JimpleLsp</li> <li>API_ASSIST</li> <li>Maybe there is more to find via Github Network Dependents - have a look at the individual modules. </li> <li>Your tool is not on this list? Create a PR :-)</li> </ul>"},{"location":"typehierarchy/","title":"TypeHierarchy","text":"<p>The TypeHierarchy models the relationship of Classes or Interfaces of a OOP program.</p>"},{"location":"typehierarchy/#creating-typehierarchy","title":"Creating TypeHierarchy","text":"SootUpSoot <pre><code>String cpString = \"src/test/resources/Callgraph/binary\";\nList&lt;AnalysisInputLocation&gt; inputLocations = new ArrayList();\ninputLocations.add(new JavaClassPathAnalysisInputLocation(cpStr));\ninputLocations.add(new DefaultRuntimeAnalysisInputLocation());\n\nJavaView view = new JavaView(inputLocations);\nTypeHierarchy typehierarchy = view.getTypeHierarchy();\n</code></pre> <pre><code>String userdir = System.getProperty(\"user.dir\");\nString sootCp = userdir + File.separator + \"target\" + File.separator + \"test-classes\"+ File.pathSeparator + \"lib\"+File.separator+\"rt.jar\";\n\nString targetTestClassName = target.exercise1.Hierarchy.class.getName();\nG.reset();\nOptions.v().set_whole_program(true);\nOptions.v().set_soot_classpath(sootCp);\nOptions.v().set_no_bodies_for_excluded(true);\nOptions.v().process_dir();\nOptions.v().set_allow_phantom_refs(true);\nOptions.v().setPhaseOption(\"jb\", \"use-original-names:true\");\nOptions.v().set_prepend_classpath(false);\nSootClass c = Scene.v().forceResolve(targetTestClassName, SootClass.BODIES);\nif (c != null)\n    c.setApplicationClass();\nScene.v().loadNecessaryClasses();\n\nHierarchy hierarchy = new Hierarchy();\n</code></pre>"},{"location":"typehierarchy/#create-a-javaclasstype","title":"Create a JavaClassType","text":"SootUpSoot <pre><code>JavaClassType classTypeA = view.getIdentifierFactory().getClassType(\"packageName.A\");\nJavaClassType classTypeB = view.getIdentifierFactory().getClassType(\"packageName.B\");\nJavaClassType classTypeC = view.getIdentifierFactory().getClassType(\"packageName.C\");\n</code></pre> <pre><code>String targetTestClassName = \"packageNameA.A\";\nSootClass methodA = Scene.v().getSootClass(targetTestClassName);\n</code></pre>"},{"location":"typehierarchy/#query-the-typehierarchy","title":"Query the TypeHierarchy","text":""},{"location":"typehierarchy/#classes","title":"Classes","text":"<pre><code>    // if the assertion fails, the following methods will throw an Exception (you don't have to call it - it's just to illustrate the assumption)\n    assert typehierarchy.contains(classTypeA);\n\n    typehierarchy.superclassOf(classTypeA);\n\n    typehierarchy.subclassesOf(classTypeA);\n\n    typehierarchy.isSubtypeOf(classTypeA, classTypeB);\n</code></pre>"},{"location":"typehierarchy/#interfaces","title":"Interfaces","text":"<pre><code>    JavaClassType iterableInterface = view.getIdentifierFactory().getClassType(\"java.lang.Iterable\");\n\n    // if any of the assertions fail, the following methods will throw an Exception (you don't have to call these - it's just to illustrate the assumptions)\n    assert typehierarchy.contains(iterableInterface);\n    assert typehierarchy.isInterface(iterableInterface);\n\n    // transitive relations as well\n    typehierarchy.implementedInterfacesOf(iterableInterface);\n    typehierarchy.implementersOf(iterableInterface);\n\n    // only the direct related relations\n    typehierarchy.directlyImplementedInterfacesOf(iterableInterface);\n    typehierarchy.directlyExtendedInterfacesOf(iterableInterface);\n</code></pre>"},{"location":"whatsnew/","title":"What's new in SootUp?","text":""},{"location":"whatsnew/#library-by-default","title":"Library by default","text":"<p>While Soot is a library and a stand-alone command-line application. SootUp, on the other hand, is designed to be a core library. It assumes that it is embedded in a client application that owns the thread of control. It can be extended with a command-line interface, included in other software projects as a library, or integrated into IDEs with JimpleLSP.</p>"},{"location":"whatsnew/#modular-architecture","title":"Modular Architecture","text":"<p>SootUp has a modular architecture, which enables its clients to include only the necessary functionality to their applications.</p> <ul> <li>core module contains the core building blocks such as the jimple IR, control flow graphs, and frontend interfaces. The rest of the modules build on the core module.</li> <li>java.core module contains parts that are essential for analyzing Java code.</li> <li>java.bytecode module contains the functionality that is necessary for taking as input java bytecode.</li> <li>java.sourcecode module contains the functionality that is necessary for taking as input java source code.  Beware: The sourcecodefrontend is currently unable to handle inputs with exceptions (try/catch/finally)! </li> <li>callgraph module contains implementations of common call graph construction algorithms such as CHA, RTA. A reimplementation of Spark pointer analysis framework is in progress.</li> <li>jimple.parser module contains the functionalty that is necessary for taking as input .jimple files.</li> <li>analysis module enables performing interprocedural dataflow analyses.</li> </ul>"},{"location":"whatsnew/#no-more-singletons","title":"No More Singletons","text":"<p>Singletons offer a single view of a single program version, which makes it impossible to analyze multiple programs or multiple versions of the same program. SootUp does not make use of singletons such the <code>Scene</code> class in the old Soot any more. It enables analyzing multiple programs simultaneously.</p>"},{"location":"whatsnew/#new-source-code-frontend","title":"New Source Code Frontend","text":"<p>Soot's JastAdd-based java frontend is not maintained anymore. In SootUp, we use WALA's well-maintained source code frontend, which will not only allow Soot to analyze Java source code, but also JavaScript and Python.</p>"},{"location":"whatsnew/#immutable-by-design","title":"Immutable by Design","text":"<p>SootUp has been designed with the goal of immutability in mind. This makes sharing objects between several entities easier, because there is no need to worry about unintended changes to other entities.</p>"},{"location":"whatsnew/#withers-instead-of-setters","title":"Withers instead of Setters","text":"<p>Due to the goal of immutability, many classes do not have setters anymore. For example, a <code>Body</code> does not have a method <code>setStmts(List&lt;Stmt&gt; stmts)</code>. Instead, a method called <code>withStmts(List&lt;Stmt&gt; stmts)</code> has been added. This does not modify the original instance, but returns a copy of the Body but with the provided <code>stmts</code> in its instance. This concept of so-called <code>with</code>-ers can be found all throughout SootUp.</p> <p>A simplified example</p> <pre><code>class Body {\n  final List&lt;Stmt&gt; stmts;\n  final List&lt;Local&gt; locals;\n\n  Body(List&lt;Stmt&gt; stmts, List&lt;Local&gt; locals) {\n    this.stmts = stmts;\n    this.locals = locals;\n  }  \n\n  Body withStmts(List&lt;Stmt&gt; stmts) { return new Body(stmts, this.locals); }\n  Body withLocals(List&lt;Local&gt; locals) { return new Body(this.stmts, locals); }\n}\n</code></pre>"},{"location":"whatsnew/#intermediate-representation","title":"Intermediate Representation","text":"<p>Jimple is the only intermediate representation (IR) in SootUp. We modified it slightly to be able to accommodate different programming languages in the future.</p>"},{"location":"write_analyses/","title":"Write your own Interprocedural Dataflow Analysis","text":""},{"location":"write_analyses/#dependencies","title":"Dependencies","text":"MavenGradle <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.soot-oss&lt;/groupId&gt;\n    &lt;artifactId&gt;sootup.analysis&lt;/artifactId&gt;\n    &lt;version&gt;&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>    compile \"org.soot-oss:sootup.analysis:1.3.0\"\n</code></pre>"},{"location":"write_analyses/#useful-knowledge","title":"Useful Knowledge","text":"<p>Background Knowledge as online lectures are available on YouTube.</p> <ul> <li>IFDS Framework</li> <li>IDE Framework</li> </ul>"},{"location":"write_analyses/#examples","title":"Examples","text":"<p>Taint Analysis, TypeState Analysis, Linear Constant Propagation, ...</p> <pre><code>// TODO incorporate &amp; guide through examples\n\nIn the meantime please have a look into the test cases of the\nanalysis submodule to see example implementations of interprocedural\ndata-flow analysis via the IFDS or IDE Framework.\n</code></pre>"}]}