package de.upb.soot.signatures.scope;

import com.google.common.base.Suppliers;
import de.upb.soot.DefaultIdentifierFactory;
import de.upb.soot.core.SootModuleInfo;
import de.upb.soot.frontends.IClassProvider;
import de.upb.soot.namespaces.INamespace;
import de.upb.soot.signatures.ModuleSignature;
import de.upb.soot.types.JavaClassTypeScope;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.function.Supplier;
import java.util.stream.Collectors;

public class JavaModule implements JavaClassTypeScope {

  // FIXME: exports everything and requires everything
  // special Module to mean "all unnamed modules"
  public static final JavaModule UNNAMED_MODULE = new JavaModule();

  // special Module to mean "everyone"
  public static final JavaModule EVERYONE_MODULE = new JavaModule();

  @Nullable private final SootModuleInfo sootModuleInfo;

  private final boolean isAutomaticModule;



  private final ModuleSignature moduleSignature;

  private final INamespace namespace;

  @Nullable private final Path aPath;

  private final Supplier<Set<String>> lazyAllPackages = Suppliers.memoize(this::getAllPackageNames);

  @Nullable private String autoGeneratedName;
  private Set<String> publicExportedPackages;
  private Set<String> publicOpenedPackages;
  private HashSet<ModuleSignature> requiresModuleSignatures;
  private HashSet<ModuleSignature> transrequiresModuleSignatures;

  private JavaModule() {
    this(null, null, false, null, null, null);
  }

  public ModuleSignature getModuleSignature() {
    return moduleSignature;
  }

  /**
   * To create an automatic module...
   *
   * @param automaticName
   */
  public JavaModule(String automaticName, @Nonnull Path aPath, @Nonnull INamespace namespace) {
    this(
        null,
        aPath,
        true,
        automaticName,
        namespace,
        DefaultIdentifierFactory.getInstance().getModuleSignature(automaticName));
  }

  /**
   * Create a module, with a real module descriptor
   *
   * @param sootModuleInfo
   */
  public JavaModule(
      @Nonnull SootModuleInfo sootModuleInfo, @Nonnull Path aPath, @Nonnull INamespace namespace) {
    this(sootModuleInfo, aPath, false, null, namespace, sootModuleInfo.getModuleSignature());
  }

  private JavaModule(
      @Nullable SootModuleInfo sootModuleInfo,
      Path aPath,
      boolean isAutomaticModule,
      @Nullable String autoGeneratedName,
      @Nullable INamespace namespace,
      ModuleSignature moduleSignature) {
    this.sootModuleInfo = sootModuleInfo;
    this.isAutomaticModule = isAutomaticModule;
    this.autoGeneratedName = autoGeneratedName;
    this.namespace = namespace;
    this.aPath = aPath;
    this.moduleSignature = moduleSignature;
  }

  public String getName() {

    if (autoGeneratedName != null) {
      return autoGeneratedName;
    }
    return sootModuleInfo.getName();
  }

  @Override
  public JavaModule getScope() {
    return this;
  }

  public Set<String> getPublicExportedPackages() {
    // automatic modules export all packages
    if (this.isAutomaticModule) {
      return getAllModulePackages();
    }
    if (publicExportedPackages == null) {
      publicExportedPackages = new HashSet<>();
      for (SootModuleInfo.PackageReference packaze : sootModuleInfo.getExportedPackages()) {
        if (packaze.isPublic()) {
          publicExportedPackages.add(packaze.getPackageName());
        }
      }
    }
    return publicExportedPackages;
  }

  public Set<String> getPublicOpenedPackages() {
    if (this.isAutomaticModule) {
      return getAllModulePackages();
    }

    if (publicOpenedPackages == null) {
      publicOpenedPackages = new HashSet<>();
      for (SootModuleInfo.PackageReference packaze : sootModuleInfo.getOpenedPackages()) {
        if (packaze.isPublic()) {
          publicOpenedPackages.add(packaze.getPackageName());
        }
      }
    }
    return publicOpenedPackages;
  }

  public boolean exportsPackage(String packaze, JavaModule toModule, JavaModuleGraph moduleGraph) {

    /// all packages are exported/open to self
    if (this == toModule) {
      return this.getAllModulePackages().contains(packaze);
    }

    // a automatic module exports all its packages
    if (this.isAutomaticModule()) {
      return this.getAllModulePackages().contains(packaze);
    }

    Set<SootModuleInfo.PackageReference> qualifiedExports =
        this.sootModuleInfo.getExportedPackages();

    if (qualifiedExports == null || qualifiedExports.isEmpty()) {
      return false; // if qualifiedExport is null, the package is not exported
    }

    Optional<SootModuleInfo.PackageReference> qualifiedExport =
        qualifiedExports.stream().filter(x -> x.getPackageName().equals(packaze)).findFirst();

    return referenceAllowsAccess(qualifiedExport, toModule);
  }

  private boolean referenceAllowsAccess(
      Optional<SootModuleInfo.PackageReference> packageRef, JavaModule toModule) {
    if (!packageRef.isPresent()) {
      return false;
    }

    if (packageRef.get().isPublic()) {
      return true;
    }

    if (toModule != EVERYONE_MODULE
        && packageRef.get().getTargetModules().contains(toModule.moduleSignature)) {
      return true;
    }

    return false;
  }

  public boolean opensPackage(String packaze, JavaModule toModule, JavaModuleGraph moduleGraph) {

    /// all packages are exported/open to self
    if (this == toModule) {
      return this.getAllPackageNames().contains(packaze);
    }

    // all packages in open and automatic modules are open
    if (this.isAutomaticModule()) {
      return this.getAllPackageNames().contains(packaze);
    }

    Set<SootModuleInfo.PackageReference> qualifiedOpens = this.sootModuleInfo.getOpenedPackages();

    if (qualifiedOpens == null || qualifiedOpens.isEmpty()) {
      return false; // if qualifiedOpens is null, the package is not exported
    }

    Optional<SootModuleInfo.PackageReference> qualifiedOpen =
        qualifiedOpens.stream().filter(x -> x.getPackageName().equals(packaze)).findFirst();

    return referenceAllowsAccess(qualifiedOpen, toModule);
  }

  public boolean isAutomaticModule() {
    return isAutomaticModule;
  }

  public INamespace getNamespace() {

    return this.namespace;
  }

  public Set<String> getAllModulePackages() {
    return lazyAllPackages.get();
  }

  // FIXME: a bit dirty...
  private Set<String> getAllPackageNames() {
    Set<String> packages = new HashSet<>();

    for (String foundClass :
        getClassesUnderDirectory(this.aPath, this.namespace.getClassProvider())) {
      int index = foundClass.lastIndexOf('.');
      if (index > 0) {

        String packageName = foundClass.substring(0, index);
        packages.add(packageName);
      }
    }
    return packages;
  }

  /**
   * FIXME: this is a dirty hack... to find all packages a module defines... because I don't want to
   * create class sources.... or anything else... I just want the package names... However, it will
   * crash with a Dex-Namespace...
   *
   * @param aPath the directory
   * @return List of found classes
   */
  private List<String> getClassesUnderDirectory(Path aPath, IClassProvider classProvider) {
    List<String> foundFiles = new ArrayList<>();

    FileVisitor<Path> fileVisitor =
        new FileVisitor<Path>() {

          @Override
          public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)
              throws IOException {
            return FileVisitResult.CONTINUE;
          }

          @Override
          public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
              throws IOException {

            String fileName = aPath.relativize(file).toString().replace(File.separatorChar, '.');

            if (fileName.endsWith(classProvider.getHandledFileType().getExtension())) {
              int index =
                  fileName.lastIndexOf("." + classProvider.getHandledFileType().getExtension());
              foundFiles.add(fileName.substring(0, index));
            }

            return FileVisitResult.CONTINUE;
          }

          @Override
          public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
            return FileVisitResult.CONTINUE;
          }

          @Override
          public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
            return FileVisitResult.CONTINUE;
          }
        };
    try {
      Files.walkFileTree(aPath, fileVisitor);
    } catch (IOException e) {
      e.printStackTrace();
    }

    return foundFiles;
  }

  public Set<ModuleSignature> getRequires() {
    if (requiresModuleSignatures == null) {
      requiresModuleSignatures = new HashSet<>();
      Set<SootModuleInfo.ModuleReference> requires = sootModuleInfo.getRequires();
      requiresModuleSignatures.addAll(
          requires.stream().map(x -> x.getModuleInfo()).collect(Collectors.toList()));
    }

    return requiresModuleSignatures;
  }

  public Set<ModuleSignature> getTransitiveRequires() {

    if (transrequiresModuleSignatures == null) {
      transrequiresModuleSignatures = new HashSet<>();
      Set<SootModuleInfo.ModuleReference> requires = sootModuleInfo.getRequires();
      transrequiresModuleSignatures.addAll(
          requires.stream()
              .filter(x -> x.isTransitive())
              .map(x -> x.getModuleInfo())
              .collect(Collectors.toList()));
    }

    return requiresModuleSignatures;
  }
}
