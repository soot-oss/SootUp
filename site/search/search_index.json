{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Welcome to FutureSoot User Guide. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class HelloWorld extends java.lang.Object { public void <init> () { HelloWorld r0 ; r0 := @this: HelloWorld ; specialinvoke r0 .< java.lang.Object : void <init> ()>(); return ; } public static void main ( java.lang.String []) { java.lang.String[] r0 ; java.io.PrintStream $r1 ; r0 := @parameter0 : java.lang.String []; $r1 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $r1 .< java.io.PrintStream : void println ( java.lang.String )>( \"Hello world!\" ); return ; } }","title":"Home"},{"location":"#home","text":"Welcome to FutureSoot User Guide. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class HelloWorld extends java.lang.Object { public void <init> () { HelloWorld r0 ; r0 := @this: HelloWorld ; specialinvoke r0 .< java.lang.Object : void <init> ()>(); return ; } public static void main ( java.lang.String []) { java.lang.String[] r0 ; java.io.PrintStream $r1 ; r0 := @parameter0 : java.lang.String []; $r1 = < java.lang.System : java.io.PrintStream out >; virtualinvoke $r1 .< java.io.PrintStream : void println ( java.lang.String )>( \"Hello world!\" ); return ; } }","title":"Home"},{"location":"BodyInterceptor/","text":"LocalSplitter LocalSplitter is a BodyInterceptor that attempts to identify and separate uses of a local variable (as definition) that are independent of each other by renaming local variables. Example 1: As shown in the example above, the local variable l1 is defined twice. It can be split up into two new local variables: l1#1 and l1#2 because the both definitions are independent of each other. Example 2: In the second example, the local variable l2 is defined thrice. But it cannot be split up into three new local variables as in the first example, because its definitions in the if-branches are not independent of each other. Therefore, it can only be split up into two local variables as shown in the figure. LocalPacker LocalPacker is a BodyInterceptor that attempts to minimize the number of local variables which are used in body by reusing them, when it is possible. It corresponds to the inverse body transformation of LocalSplitter. Note: Every local variable's type should be assigned before running LocalPacker. Example: In the given example above, the local variables l1 , l3 are summarized to be one local variable l1 , because they have the same type without interference with each other. Likewise, the local variables l2 , l4 and l5 are summarized to be another local variable l2 . Although the local variable l0 doesn't interfere any other local variables, it cannot be summed up with other local variables because of its distinctive type. TrapTightener TrapTightener is a BodyInterceptor that shrinks the protected area covered by each Trap in a Body. Example: We assume in the example above that only the Stmt : l2 := 2 might throw an exception caught by the Trap which is labeled with label3 . In the jimple body before running the TrapTightener, the protected area covered by the Trap contains three Stmts : l1 := 1; l2 := 2; l2 := 3 . But an exception could only arise at the Stmt : l2 := 2 . After the implementation of TrapTightener, we will get a contractible protected area which contains only the Stmt that might throw an exception, namely the Stmt : l2 := 2 . EmptySwitchEliminator EmptySwitchEliminator is a BodyInterceptor that removes empty switch statements which contain only the default case. Example: As shown in the example above, the switch statement in the jimple body always takes the default action. After running EmptySwitchEliminator, the switch statement is replaced with a GotoStmt to the default case. UnreachableCodeEliminator UnreachableCodeEliminator is a BodyInterceptor that removes all unreachable statements. Example: Obviously, the code segment l2 = 2; l3 = 3; is unreachable. It will be removed after running the UreachableCodeEliminator. CopyPropagator CopyPropagator is a BodyInterceptor that supports the global copy propagation and constant propagation. Example for global copy propagation: Consider a code segment in the following form: 1 2 3 a = b; ... c = use(a); // a, b, c are local variables According to the copy propagation's definition, the statement c = use(a) can be replaced with c = use(b) iff both conditions are met: a is defined only one time on all the paths from a = b to c = use(a) . There are no definitions of b on any path from a = b to c = use(a) . In the example for global copy propagation, the first used l1 is replaced with l0 , but the second used l1 cannot be replaced with l3 , because the second condition is not satisfied. Example for constant propagation: Constant propagation is similar to copy propagation. Consider a code segment in the following form: 1 2 3 a = const; ... b = use(a); // a, b are local variables, const is a constant After perfoming the constant propagation, the statement b = use(a) can be replaced with b = use(const) iff a is not redefined on any of the paths from a = const to b = use(a) . Therefore, the first used l1 in the second example can be replaced with the constant 1 , but the second used l1 cannot be replaced with the constant 2 , because l1 is redefined on the path from l1 = 2 to l4 = use(l1) . However, it can be replaced with local variable l2 , because the both conditions of copy propagation are met. LocalNameStandardizer LocalNameStandardizer is a BodyInterceptor that assigns a generic name to each local variable. Firstly, it will sort the local variables' order alphabetically by the string representation of their type. If there are two local variables with the same type, then the LocalNameStandardizer will use the sequence of their occurrence in jimple body to determine their order. Each assigned name consists of two parts: A letter to imply the local variable's type A digit to imply the local variable's order The following table shows the letter corresponding to each type: Type of Local Variable Letter boolean z byte b short s int i long l float f double d char c null n unknown e reference r StaticSingleAssignmentFormer StaticSingleAssignmentFormer is a BodyInterceptor that transforms jimple body into SSA form, so that each local variable is assigned exactly once and defined before its first use. Example: In the given example, the StaticSingleAssignmentFormer assigns each IdentityStmt and AssignStmt to a new local variable . And each use uses the local variable which is most recently defined. Sometimes, it is impossible to determine the most recently defined local variable for a use in a join block. In this case, the StaticSingleAssignmentFormer will insert a PhiStmt in the front of the join block to merge all most recently defined local variables and assign them a new local variable.","title":"Body Interceptors"},{"location":"BodyInterceptor/#localsplitter","text":"LocalSplitter is a BodyInterceptor that attempts to identify and separate uses of a local variable (as definition) that are independent of each other by renaming local variables. Example 1: As shown in the example above, the local variable l1 is defined twice. It can be split up into two new local variables: l1#1 and l1#2 because the both definitions are independent of each other. Example 2: In the second example, the local variable l2 is defined thrice. But it cannot be split up into three new local variables as in the first example, because its definitions in the if-branches are not independent of each other. Therefore, it can only be split up into two local variables as shown in the figure.","title":"LocalSplitter"},{"location":"BodyInterceptor/#localpacker","text":"LocalPacker is a BodyInterceptor that attempts to minimize the number of local variables which are used in body by reusing them, when it is possible. It corresponds to the inverse body transformation of LocalSplitter. Note: Every local variable's type should be assigned before running LocalPacker. Example: In the given example above, the local variables l1 , l3 are summarized to be one local variable l1 , because they have the same type without interference with each other. Likewise, the local variables l2 , l4 and l5 are summarized to be another local variable l2 . Although the local variable l0 doesn't interfere any other local variables, it cannot be summed up with other local variables because of its distinctive type.","title":"LocalPacker"},{"location":"BodyInterceptor/#traptightener","text":"TrapTightener is a BodyInterceptor that shrinks the protected area covered by each Trap in a Body. Example: We assume in the example above that only the Stmt : l2 := 2 might throw an exception caught by the Trap which is labeled with label3 . In the jimple body before running the TrapTightener, the protected area covered by the Trap contains three Stmts : l1 := 1; l2 := 2; l2 := 3 . But an exception could only arise at the Stmt : l2 := 2 . After the implementation of TrapTightener, we will get a contractible protected area which contains only the Stmt that might throw an exception, namely the Stmt : l2 := 2 .","title":"TrapTightener"},{"location":"BodyInterceptor/#emptyswitcheliminator","text":"EmptySwitchEliminator is a BodyInterceptor that removes empty switch statements which contain only the default case. Example: As shown in the example above, the switch statement in the jimple body always takes the default action. After running EmptySwitchEliminator, the switch statement is replaced with a GotoStmt to the default case.","title":"EmptySwitchEliminator"},{"location":"BodyInterceptor/#unreachablecodeeliminator","text":"UnreachableCodeEliminator is a BodyInterceptor that removes all unreachable statements. Example: Obviously, the code segment l2 = 2; l3 = 3; is unreachable. It will be removed after running the UreachableCodeEliminator.","title":"UnreachableCodeEliminator"},{"location":"BodyInterceptor/#copypropagator","text":"CopyPropagator is a BodyInterceptor that supports the global copy propagation and constant propagation. Example for global copy propagation: Consider a code segment in the following form: 1 2 3 a = b; ... c = use(a); // a, b, c are local variables According to the copy propagation's definition, the statement c = use(a) can be replaced with c = use(b) iff both conditions are met: a is defined only one time on all the paths from a = b to c = use(a) . There are no definitions of b on any path from a = b to c = use(a) . In the example for global copy propagation, the first used l1 is replaced with l0 , but the second used l1 cannot be replaced with l3 , because the second condition is not satisfied. Example for constant propagation: Constant propagation is similar to copy propagation. Consider a code segment in the following form: 1 2 3 a = const; ... b = use(a); // a, b are local variables, const is a constant After perfoming the constant propagation, the statement b = use(a) can be replaced with b = use(const) iff a is not redefined on any of the paths from a = const to b = use(a) . Therefore, the first used l1 in the second example can be replaced with the constant 1 , but the second used l1 cannot be replaced with the constant 2 , because l1 is redefined on the path from l1 = 2 to l4 = use(l1) . However, it can be replaced with local variable l2 , because the both conditions of copy propagation are met.","title":"CopyPropagator"},{"location":"BodyInterceptor/#localnamestandardizer","text":"LocalNameStandardizer is a BodyInterceptor that assigns a generic name to each local variable. Firstly, it will sort the local variables' order alphabetically by the string representation of their type. If there are two local variables with the same type, then the LocalNameStandardizer will use the sequence of their occurrence in jimple body to determine their order. Each assigned name consists of two parts: A letter to imply the local variable's type A digit to imply the local variable's order The following table shows the letter corresponding to each type: Type of Local Variable Letter boolean z byte b short s int i long l float f double d char c null n unknown e reference r","title":"LocalNameStandardizer"},{"location":"BodyInterceptor/#staticsingleassignmentformer","text":"StaticSingleAssignmentFormer is a BodyInterceptor that transforms jimple body into SSA form, so that each local variable is assigned exactly once and defined before its first use. Example: In the given example, the StaticSingleAssignmentFormer assigns each IdentityStmt and AssignStmt to a new local variable . And each use uses the local variable which is most recently defined. Sometimes, it is impossible to determine the most recently defined local variable for a use in a join block. In this case, the StaticSingleAssignmentFormer will insert a PhiStmt in the front of the join block to merge all most recently defined local variables and assign them a new local variable.","title":"StaticSingleAssignmentFormer"},{"location":"Tools/","text":"LocalLivenessAnalyser LocalLivenessAnalyser is used for querying for the list of live local variables before and after a given Stmt . Example: The live local variables before and after each Stmt will be calculated after generating an instance of LocalLivenessAnalyser as shown the example above. They can be queried by using the methods getLiveLocalsBeforeStmt and getLiveLocalsAfterStmt . DominanceFinder DomianceFinder is used for querying for the immediate dominator and dominance frontiers for a given basic block. Example: After generating an instance of DominanceFinder for a BlockGraph , we will get the immediate dominator and dominance frontiers for each basic block. The both properties can be queried by using the methods getImmediateDominator and getDominanceFrontiers .","title":"Tools"},{"location":"Tools/#locallivenessanalyser","text":"LocalLivenessAnalyser is used for querying for the list of live local variables before and after a given Stmt . Example: The live local variables before and after each Stmt will be calculated after generating an instance of LocalLivenessAnalyser as shown the example above. They can be queried by using the methods getLiveLocalsBeforeStmt and getLiveLocalsAfterStmt .","title":"LocalLivenessAnalyser"},{"location":"Tools/#dominancefinder","text":"DomianceFinder is used for querying for the immediate dominator and dominance frontiers for a given basic block. Example: After generating an instance of DominanceFinder for a BlockGraph , we will get the immediate dominator and dominance frontiers for each basic block. The both properties can be queried by using the methods getImmediateDominator and getDominanceFrontiers .","title":"DominanceFinder"},{"location":"docguide/","text":"General MkDocsExtensions Tooltip Hover me Example File inclusion this enables that tutorial code can be tested and will fail if its not up to date anymore :) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 package de.upb.swt.soot.examples.basicSetup; import static org.junit.Assert.assertTrue; import categories.Java8Test; import sootup.core.Language; import sootup.core.Project; import sootup.core.inputlocation.AnalysisInputLocation; import sootup.core.jimple.common.expr.JVirtualInvokeExpr; import sootup.core.jimple.common.stmt.JInvokeStmt; import sootup.core.model.SootClass; import sootup.core.model.SootMethod; import sootup.core.signatures.MethodSignature; import sootup.core.types.ClassType; import sootup.core.views.View; import sootup.java.bytecode.inputlocation.PathBasedAnalysisInputLocation; import sootup.java.core.JavaProject; import sootup.java.core.JavaSootClass; import sootup.java.core.JavaSootClassSource; import sootup.java.core.language.JavaJimple; import sootup.java.core.language.JavaLanguage; import sootup.java.sourcecode.inputlocation.JavaSourcePathAnalysisInputLocation; import sootup.jimple.parser.JimpleAnalysisInputLocation; import sootup.jimple.parser.JimpleProject; import java.nio.file.Path; import java.nio.file.Paths; import java.util.Collections; import org.junit.Ignore; import org.junit.Test; import org.junit.experimental.categories.Category; /** This example illustrates how to create and use a new Soot Project. */ @Category(Java8Test.class) public class BasicSetup { @Test public void createSourceCodeProject() { Path pathToSource = Paths.get(\"src/test/resources/BasicSetup/source\"); AnalysisInputLocation<JavaSootClass> inputLocation = new JavaSourcePathAnalysisInputLocation(pathToSource.toString()); Language language = new JavaLanguage(8); Project project = JavaProject.builder((JavaLanguage) language).addInputLocation(inputLocation).build(); } @Ignore public void createJimpleProject() { Path pathToJimple = Paths.get(\"src/test/resources/BasicSetup/jimple\"); AnalysisInputLocation<JavaSootClass> inputLocation = new JimpleAnalysisInputLocation(pathToJimple); Project project = new JimpleProject(inputLocation); } @Test public void createByteCodeProject() { // Create a AnalysisInputLocation, which points to a directory. All class files will be loaded // from the directory Path pathToBinary = Paths.get(\"src/test/resources/BasicSetup/binary\"); AnalysisInputLocation<JavaSootClass> inputLocation = PathBasedAnalysisInputLocation.createForClassContainer(pathToBinary); // Specify the language of the JavaProject. This is especially relevant for Multi-release jars, // where classes are loaded depending on the language level of the analysis Language language = new JavaLanguage(8); // Create a new JavaProject based on the input location Project project = JavaProject.builder((JavaLanguage) language).addInputLocation(inputLocation).build(); // Create a signature for the class we want to analyze ClassType classType = project.getIdentifierFactory().getClassType(\"HelloWorld\"); // Create a signature for the method we want to analyze MethodSignature methodSignature = project .getIdentifierFactory() .getMethodSignature( \"main\", classType, \"void\", Collections.singletonList(\"java.lang.String[]\")); // Create a view for project, which allows us to retrieve classes View view = project.createOnDemandView(); // Assert that class is present assertTrue(view.getClass(classType).isPresent()); // Retrieve class SootClass<JavaSootClassSource> sootClass = (SootClass<JavaSootClassSource>) view.getClass(classType).get(); // Retrieve method view.getMethod(methodSignature); // Alternatively: assertTrue(sootClass.getMethod(methodSignature.getSubSignature()).isPresent()); SootMethod sootMethod = sootClass.getMethod(methodSignature.getSubSignature()).get(); // Read jimple code of method System.out.println(sootMethod.getBody()); // Assert that Hello world print is present assertTrue( sootMethod.getBody().getStmts().stream() .anyMatch( stmt -> stmt instanceof JInvokeStmt && stmt.getInvokeExpr() instanceof JVirtualInvokeExpr && stmt.getInvokeExpr() .getArg(0) .equivTo(JavaJimple.getInstance().newStringConstant(\"Hello World!\")))); } }","title":"Docguide"},{"location":"docguide/#general","text":"","title":"General"},{"location":"docguide/#mkdocsextensions","text":"","title":"MkDocsExtensions"},{"location":"docguide/#tooltip","text":"Hover me","title":"Tooltip"},{"location":"docguide/#example-file-inclusion","text":"this enables that tutorial code can be tested and will fail if its not up to date anymore :) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 package de.upb.swt.soot.examples.basicSetup; import static org.junit.Assert.assertTrue; import categories.Java8Test; import sootup.core.Language; import sootup.core.Project; import sootup.core.inputlocation.AnalysisInputLocation; import sootup.core.jimple.common.expr.JVirtualInvokeExpr; import sootup.core.jimple.common.stmt.JInvokeStmt; import sootup.core.model.SootClass; import sootup.core.model.SootMethod; import sootup.core.signatures.MethodSignature; import sootup.core.types.ClassType; import sootup.core.views.View; import sootup.java.bytecode.inputlocation.PathBasedAnalysisInputLocation; import sootup.java.core.JavaProject; import sootup.java.core.JavaSootClass; import sootup.java.core.JavaSootClassSource; import sootup.java.core.language.JavaJimple; import sootup.java.core.language.JavaLanguage; import sootup.java.sourcecode.inputlocation.JavaSourcePathAnalysisInputLocation; import sootup.jimple.parser.JimpleAnalysisInputLocation; import sootup.jimple.parser.JimpleProject; import java.nio.file.Path; import java.nio.file.Paths; import java.util.Collections; import org.junit.Ignore; import org.junit.Test; import org.junit.experimental.categories.Category; /** This example illustrates how to create and use a new Soot Project. */ @Category(Java8Test.class) public class BasicSetup { @Test public void createSourceCodeProject() { Path pathToSource = Paths.get(\"src/test/resources/BasicSetup/source\"); AnalysisInputLocation<JavaSootClass> inputLocation = new JavaSourcePathAnalysisInputLocation(pathToSource.toString()); Language language = new JavaLanguage(8); Project project = JavaProject.builder((JavaLanguage) language).addInputLocation(inputLocation).build(); } @Ignore public void createJimpleProject() { Path pathToJimple = Paths.get(\"src/test/resources/BasicSetup/jimple\"); AnalysisInputLocation<JavaSootClass> inputLocation = new JimpleAnalysisInputLocation(pathToJimple); Project project = new JimpleProject(inputLocation); } @Test public void createByteCodeProject() { // Create a AnalysisInputLocation, which points to a directory. All class files will be loaded // from the directory Path pathToBinary = Paths.get(\"src/test/resources/BasicSetup/binary\"); AnalysisInputLocation<JavaSootClass> inputLocation = PathBasedAnalysisInputLocation.createForClassContainer(pathToBinary); // Specify the language of the JavaProject. This is especially relevant for Multi-release jars, // where classes are loaded depending on the language level of the analysis Language language = new JavaLanguage(8); // Create a new JavaProject based on the input location Project project = JavaProject.builder((JavaLanguage) language).addInputLocation(inputLocation).build(); // Create a signature for the class we want to analyze ClassType classType = project.getIdentifierFactory().getClassType(\"HelloWorld\"); // Create a signature for the method we want to analyze MethodSignature methodSignature = project .getIdentifierFactory() .getMethodSignature( \"main\", classType, \"void\", Collections.singletonList(\"java.lang.String[]\")); // Create a view for project, which allows us to retrieve classes View view = project.createOnDemandView(); // Assert that class is present assertTrue(view.getClass(classType).isPresent()); // Retrieve class SootClass<JavaSootClassSource> sootClass = (SootClass<JavaSootClassSource>) view.getClass(classType).get(); // Retrieve method view.getMethod(methodSignature); // Alternatively: assertTrue(sootClass.getMethod(methodSignature.getSubSignature()).isPresent()); SootMethod sootMethod = sootClass.getMethod(methodSignature.getSubSignature()).get(); // Read jimple code of method System.out.println(sootMethod.getBody()); // Assert that Hello world print is present assertTrue( sootMethod.getBody().getStmts().stream() .anyMatch( stmt -> stmt instanceof JInvokeStmt && stmt.getInvokeExpr() instanceof JVirtualInvokeExpr && stmt.getInvokeExpr() .getArg(0) .equivTo(JavaJimple.getInstance().newStringConstant(\"Hello World!\")))); } }","title":"Example File inclusion"},{"location":"getting-started/","text":"Getting Started This new version enables Soot users to use Soot in a much more flexible manner. Particularly, we introduce the following major, breaking changes: Library by default. This version of Soot assumes that it\u2019s embedded in a client application that owns the thread of control. This analysis client can use off Soot whatever is needed. We also plan to implement a command-line client which implements a default control thread to load into Soot certain code projects, have them analyzed/transformed, similarly to how old Soot was used. No singleton such the Scene class in the old Soot any more. A much more decoupled, modular design allows users to parallelize analysis of multiple projects. We use WALA's source code front ends to support more languages. This will not only allow Soot to analyze Java source code, but also JavaScript and Python. Jimple is the only intermediate representation (IR) in this new version and it undergos slight changes to accommodate different programming languages. Immutable by design. This allows users to have multiple views on the code. Jimple-modification is still possible. Core Data Structures Before you use Soot as a library, you need understand the following data structures at first: Project : defines the outlines of an analysis. Soot users should first create a Project instance. It is the starting point for all operations. You can define multiple instances of Project at the same time and there are no information shared between them. All caches are always at the project level. Language : represents the programming language of the analyzed code. AnalysisInputLocation : defines where to find the analyzed code. It is like the cp option in the old Soot, which specifies the classpath for Soot to find classes to be analyzed. View : presents the code/classes under analysis. It can been seen as a replacement of the Scene class, but it is not a singletion class. Scope : defines the scope of the View . By default, the View is created with all code found on the AnalysisInputLocation specified for the Project instance. SootClass : represents a class loaded into the View . SootMethod : represents a method of a class. SootField : represents a field of a class. Body : represents a method body in Jimpe. StmtGraph : represents the control flow graph of a method body in Jimple statements. Signature : represents a class ,a methods or a field and they have the following structure: 1 2 3 4 <DeclaringClassPackages.DeclaringClass> <DeclaringClassPackages.DeclaringClass: methodName()> <DeclaringClassPackages.DeclaringClass: methodName(parameterType1,parameterType2 )> <DeclaringClassPackages.DeclaringClass: FieldTypePackage.FieldType FieldName> Add Soot as Library Dependency to Your Project Maven TODO Gradle TODO Eclipse TODO Basic Project Setup Create a project to analyze Java bytecode. 1 2 3 4 Path pathToBinary = Paths . get ( \"src/test/resources/BasicSetup/binary\" ); AnalysisInputLocation < JavaSootClass > inputLocation = PathBasedAnalysisInputLocation . createForClassContainer ( pathToBinary ; Language language = new JavaLanguage ( 8 ); Project project = JavaProject . builder (( JavaLanguage ) language ). addInputLocation ( inputLocation ). build (); Create a project to analyze Java source code. 1 2 3 4 Path pathToSource = Paths . get ( \"src/test/resources/BasicSetup/source\" ); AnalysisInputLocation < JavaSootClass > inputLocation = new JavaSourcePathAnalysisInputLocation ( pathToSource . toString ()); Language language = new JavaLanguage ( 8 ); Project project = JavaProject . builder (( JavaLanguage ) language ). addInputLocation ( inputLocation ). build (); Create a project to analyze Android APK. TODO: add code Create a project to analyze Jimple code. 1 2 3 Path pathToJimple = Paths . get ( \"src/test/resources/BasicSetup/jimple\" ); AnalysisInputLocation < JavaSootClass > inputLocation = new JimpleAnalysisInputLocation ( pathToJimple ); Project project = new JimpleProject ( inputLocation ); Create Different Views Create a full view of all classes found in given analysis input location. 1 project . createFullView (); Create a on-demand view. An on-demand view does not load all classes into the view, but only classes that are specified and their transitive closure. TODO: add code Create a view based on a defined scope. TODO: add code Perform an Intra-procedural Analysis Construct Call Graph Perform an Inter-procedural Analysis All Code Used Aboves 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 package de.upb.swt.soot.examples.basicSetup ; import static org.junit.Assert.assertTrue ; import categories.Java8Test ; import sootup.core.Language ; import sootup.core.Project ; import sootup.core.inputlocation.AnalysisInputLocation ; import sootup.core.jimple.common.expr.JVirtualInvokeExpr ; import sootup.core.jimple.common.stmt.JInvokeStmt ; import sootup.core.model.SootClass ; import sootup.core.model.SootMethod ; import sootup.core.signatures.MethodSignature ; import sootup.core.types.ClassType ; import sootup.core.views.View ; import sootup.java.bytecode.inputlocation.PathBasedAnalysisInputLocation ; import sootup.java.core.JavaProject ; import sootup.java.core.JavaSootClass ; import sootup.java.core.JavaSootClassSource ; import sootup.java.core.language.JavaJimple ; import sootup.java.core.language.JavaLanguage ; import sootup.java.sourcecode.inputlocation.JavaSourcePathAnalysisInputLocation ; import sootup.jimple.parser.JimpleAnalysisInputLocation ; import sootup.jimple.parser.JimpleProject ; import java.nio.file.Path ; import java.nio.file.Paths ; import java.util.Collections ; import org.junit.Ignore ; import org.junit.Test ; import org.junit.experimental.categories.Category ; /** This example illustrates how to create and use a new Soot Project. */ @Category ( Java8Test . class ) public class BasicSetup { @Test public void createSourceCodeProject () { Path pathToSource = Paths . get ( \"src/test/resources/BasicSetup/source\" ); AnalysisInputLocation < JavaSootClass > inputLocation = new JavaSourcePathAnalysisInputLocation ( pathToSource . toString ()); Language language = new JavaLanguage ( 8 ); Project project = JavaProject . builder (( JavaLanguage ) language ). addInputLocation ( inputLocation ). build (); } @Ignore public void createJimpleProject () { Path pathToJimple = Paths . get ( \"src/test/resources/BasicSetup/jimple\" ); AnalysisInputLocation < JavaSootClass > inputLocation = new JimpleAnalysisInputLocation ( pathToJimple ); Project project = new JimpleProject ( inputLocation ); } @Test public void createByteCodeProject () { // Create a AnalysisInputLocation, which points to a directory. All class files will be loaded // from the directory Path pathToBinary = Paths . get ( \"src/test/resources/BasicSetup/binary\" ); AnalysisInputLocation < JavaSootClass > inputLocation = PathBasedAnalysisInputLocation . createForClassContainer ( pathToBinary ); // Specify the language of the JavaProject. This is especially relevant for Multi-release jars, // where classes are loaded depending on the language level of the analysis Language language = new JavaLanguage ( 8 ); // Create a new JavaProject based on the input location Project project = JavaProject . builder (( JavaLanguage ) language ). addInputLocation ( inputLocation ). build (); // Create a signature for the class we want to analyze ClassType classType = project . getIdentifierFactory (). getClassType ( \"HelloWorld\" ); // Create a signature for the method we want to analyze MethodSignature methodSignature = project . getIdentifierFactory () . getMethodSignature ( \"main\" , classType , \"void\" , Collections . singletonList ( \"java.lang.String[]\" )); // Create a view for project, which allows us to retrieve classes View view = project . createOnDemandView (); // Assert that class is present assertTrue ( view . getClass ( classType ). isPresent ()); // Retrieve class SootClass < JavaSootClassSource > sootClass = ( SootClass < JavaSootClassSource > ) view . getClass ( classType ). get (); // Retrieve method view . getMethod ( methodSignature ); // Alternatively: assertTrue ( sootClass . getMethod ( methodSignature . getSubSignature ()). isPresent ()); SootMethod sootMethod = sootClass . getMethod ( methodSignature . getSubSignature ()). get (); // Read jimple code of method System . out . println ( sootMethod . getBody ()); // Assert that Hello world print is present assertTrue ( sootMethod . getBody (). getStmts (). stream () . anyMatch ( stmt -> stmt instanceof JInvokeStmt && stmt . getInvokeExpr () instanceof JVirtualInvokeExpr && stmt . getInvokeExpr () . getArg ( 0 ) . equivTo ( JavaJimple . getInstance (). newStringConstant ( \"Hello World!\" )))); } }","title":"Getting started"},{"location":"getting-started/#getting-started","text":"This new version enables Soot users to use Soot in a much more flexible manner. Particularly, we introduce the following major, breaking changes: Library by default. This version of Soot assumes that it\u2019s embedded in a client application that owns the thread of control. This analysis client can use off Soot whatever is needed. We also plan to implement a command-line client which implements a default control thread to load into Soot certain code projects, have them analyzed/transformed, similarly to how old Soot was used. No singleton such the Scene class in the old Soot any more. A much more decoupled, modular design allows users to parallelize analysis of multiple projects. We use WALA's source code front ends to support more languages. This will not only allow Soot to analyze Java source code, but also JavaScript and Python. Jimple is the only intermediate representation (IR) in this new version and it undergos slight changes to accommodate different programming languages. Immutable by design. This allows users to have multiple views on the code. Jimple-modification is still possible.","title":"Getting Started"},{"location":"getting-started/#core-data-structures","text":"Before you use Soot as a library, you need understand the following data structures at first: Project : defines the outlines of an analysis. Soot users should first create a Project instance. It is the starting point for all operations. You can define multiple instances of Project at the same time and there are no information shared between them. All caches are always at the project level. Language : represents the programming language of the analyzed code. AnalysisInputLocation : defines where to find the analyzed code. It is like the cp option in the old Soot, which specifies the classpath for Soot to find classes to be analyzed. View : presents the code/classes under analysis. It can been seen as a replacement of the Scene class, but it is not a singletion class. Scope : defines the scope of the View . By default, the View is created with all code found on the AnalysisInputLocation specified for the Project instance. SootClass : represents a class loaded into the View . SootMethod : represents a method of a class. SootField : represents a field of a class. Body : represents a method body in Jimpe. StmtGraph : represents the control flow graph of a method body in Jimple statements. Signature : represents a class ,a methods or a field and they have the following structure: 1 2 3 4 <DeclaringClassPackages.DeclaringClass> <DeclaringClassPackages.DeclaringClass: methodName()> <DeclaringClassPackages.DeclaringClass: methodName(parameterType1,parameterType2 )> <DeclaringClassPackages.DeclaringClass: FieldTypePackage.FieldType FieldName>","title":"Core Data Structures"},{"location":"getting-started/#add-soot-as-library-dependency-to-your-project","text":"Maven TODO Gradle TODO Eclipse TODO","title":"Add Soot as Library Dependency to Your Project"},{"location":"getting-started/#basic-project-setup","text":"Create a project to analyze Java bytecode. 1 2 3 4 Path pathToBinary = Paths . get ( \"src/test/resources/BasicSetup/binary\" ); AnalysisInputLocation < JavaSootClass > inputLocation = PathBasedAnalysisInputLocation . createForClassContainer ( pathToBinary ; Language language = new JavaLanguage ( 8 ); Project project = JavaProject . builder (( JavaLanguage ) language ). addInputLocation ( inputLocation ). build (); Create a project to analyze Java source code. 1 2 3 4 Path pathToSource = Paths . get ( \"src/test/resources/BasicSetup/source\" ); AnalysisInputLocation < JavaSootClass > inputLocation = new JavaSourcePathAnalysisInputLocation ( pathToSource . toString ()); Language language = new JavaLanguage ( 8 ); Project project = JavaProject . builder (( JavaLanguage ) language ). addInputLocation ( inputLocation ). build (); Create a project to analyze Android APK. TODO: add code Create a project to analyze Jimple code. 1 2 3 Path pathToJimple = Paths . get ( \"src/test/resources/BasicSetup/jimple\" ); AnalysisInputLocation < JavaSootClass > inputLocation = new JimpleAnalysisInputLocation ( pathToJimple ); Project project = new JimpleProject ( inputLocation );","title":"Basic Project Setup"},{"location":"getting-started/#create-different-views","text":"Create a full view of all classes found in given analysis input location. 1 project . createFullView (); Create a on-demand view. An on-demand view does not load all classes into the view, but only classes that are specified and their transitive closure. TODO: add code Create a view based on a defined scope. TODO: add code","title":"Create Different Views"},{"location":"getting-started/#perform-an-intra-procedural-analysis","text":"","title":"Perform an Intra-procedural Analysis"},{"location":"getting-started/#construct-call-graph","text":"","title":"Construct Call Graph"},{"location":"getting-started/#perform-an-inter-procedural-analysis","text":"","title":"Perform an Inter-procedural Analysis"},{"location":"getting-started/#all-code-used-aboves","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 package de.upb.swt.soot.examples.basicSetup ; import static org.junit.Assert.assertTrue ; import categories.Java8Test ; import sootup.core.Language ; import sootup.core.Project ; import sootup.core.inputlocation.AnalysisInputLocation ; import sootup.core.jimple.common.expr.JVirtualInvokeExpr ; import sootup.core.jimple.common.stmt.JInvokeStmt ; import sootup.core.model.SootClass ; import sootup.core.model.SootMethod ; import sootup.core.signatures.MethodSignature ; import sootup.core.types.ClassType ; import sootup.core.views.View ; import sootup.java.bytecode.inputlocation.PathBasedAnalysisInputLocation ; import sootup.java.core.JavaProject ; import sootup.java.core.JavaSootClass ; import sootup.java.core.JavaSootClassSource ; import sootup.java.core.language.JavaJimple ; import sootup.java.core.language.JavaLanguage ; import sootup.java.sourcecode.inputlocation.JavaSourcePathAnalysisInputLocation ; import sootup.jimple.parser.JimpleAnalysisInputLocation ; import sootup.jimple.parser.JimpleProject ; import java.nio.file.Path ; import java.nio.file.Paths ; import java.util.Collections ; import org.junit.Ignore ; import org.junit.Test ; import org.junit.experimental.categories.Category ; /** This example illustrates how to create and use a new Soot Project. */ @Category ( Java8Test . class ) public class BasicSetup { @Test public void createSourceCodeProject () { Path pathToSource = Paths . get ( \"src/test/resources/BasicSetup/source\" ); AnalysisInputLocation < JavaSootClass > inputLocation = new JavaSourcePathAnalysisInputLocation ( pathToSource . toString ()); Language language = new JavaLanguage ( 8 ); Project project = JavaProject . builder (( JavaLanguage ) language ). addInputLocation ( inputLocation ). build (); } @Ignore public void createJimpleProject () { Path pathToJimple = Paths . get ( \"src/test/resources/BasicSetup/jimple\" ); AnalysisInputLocation < JavaSootClass > inputLocation = new JimpleAnalysisInputLocation ( pathToJimple ); Project project = new JimpleProject ( inputLocation ); } @Test public void createByteCodeProject () { // Create a AnalysisInputLocation, which points to a directory. All class files will be loaded // from the directory Path pathToBinary = Paths . get ( \"src/test/resources/BasicSetup/binary\" ); AnalysisInputLocation < JavaSootClass > inputLocation = PathBasedAnalysisInputLocation . createForClassContainer ( pathToBinary ); // Specify the language of the JavaProject. This is especially relevant for Multi-release jars, // where classes are loaded depending on the language level of the analysis Language language = new JavaLanguage ( 8 ); // Create a new JavaProject based on the input location Project project = JavaProject . builder (( JavaLanguage ) language ). addInputLocation ( inputLocation ). build (); // Create a signature for the class we want to analyze ClassType classType = project . getIdentifierFactory (). getClassType ( \"HelloWorld\" ); // Create a signature for the method we want to analyze MethodSignature methodSignature = project . getIdentifierFactory () . getMethodSignature ( \"main\" , classType , \"void\" , Collections . singletonList ( \"java.lang.String[]\" )); // Create a view for project, which allows us to retrieve classes View view = project . createOnDemandView (); // Assert that class is present assertTrue ( view . getClass ( classType ). isPresent ()); // Retrieve class SootClass < JavaSootClassSource > sootClass = ( SootClass < JavaSootClassSource > ) view . getClass ( classType ). get (); // Retrieve method view . getMethod ( methodSignature ); // Alternatively: assertTrue ( sootClass . getMethod ( methodSignature . getSubSignature ()). isPresent ()); SootMethod sootMethod = sootClass . getMethod ( methodSignature . getSubSignature ()). get (); // Read jimple code of method System . out . println ( sootMethod . getBody ()); // Assert that Hello world print is present assertTrue ( sootMethod . getBody (). getStmts (). stream () . anyMatch ( stmt -> stmt instanceof JInvokeStmt && stmt . getInvokeExpr () instanceof JVirtualInvokeExpr && stmt . getInvokeExpr () . getArg ( 0 ) . equivTo ( JavaJimple . getInstance (). newStringConstant ( \"Hello World!\" )))); } }","title":"All Code Used Aboves"},{"location":"installation/","text":"Installation to appear","title":"Installation"},{"location":"installation/#installation","text":"to appear","title":"Installation"},{"location":"jimple/","text":"Jimple What is Jimple? Jimple is the intermediate representation IR of Soot. Soots intention is to provide a simplified way to analyze JVM bytecode. For this purpose Jimple was designed as a representation of JVM bytecode which is human readable. Jimple Grammar Structure Jimple mimics the JVMs class file structure. Therefore it is object oriented. A Single Class (or Interface) per file. Three-Address-Code which means there are no nested expressions. (nested expressions can be modeled via Locals that store intermediate calculation results.) Class (or Interface) A class consists of Fields and Methods. It is referenced by its ClassType. Field A Field is a piece of memory which can store a value that is accessible according to its visibility modifier. It is referenced by its FieldSignature. Method and the Body The interesting part is a method. A method is a \"piece of code\" that can be executed. It is referenced by its MethodSignature and contains a StmtGraph that models the sequence of single instructions/statements (Stmts). Signatures Everything that we can reference across a method (e.g. a Class, Interface, Method or Field) - which is basically every item//TODO:wording that is not a Local - has a Signature. Trap A Trap is a mechanism to model exceptional flow. Stmt The main piece of Jimple is a Statement (Stmt). Stmts represent that can be executed by the JVM. Branching Statements A BranchingStmt's job is to model the flow between Stmts. JGotoStmt for unconditional flow JIfStmt for conditional flow depending on boolean Expression (AbstractConditionExpr) so they have two successor Stmt's JSwitchStmt for conditional flow that behaves like a switch-case. It has #numberOfCaseLabels+1 (for default) successor Stmt's. All other Stmts are not manipulating the flow, which means they have a single successor Stmt as long as they are not exiting the flow inside a method. JReturnStmt & JReturnVoidStmt They end the execution/flow inside the current method and return (a value) to its caller. JThrowStmt Ends the execution inside the current Method if the thrown exception is not caught by a Trap, which redirects the execution to an exceptionhandler JInvokeStmt transfers the control flow to another method until the called method returns. JAssignStmt assigns a Value from the right handside to the left handside. On the left handside can occure a Local referencing a variable (i.e. a Local) or a FieldRef referencing a Field. On the right handside can be an expression (Expr), a Local, a FieldRef or a Constant. JIdentityStmt is semantically like the JAssignStmt and handles assignments of IdentityRef's to make implicit assignments explicit into the StmtGraph. JEnterMonitorStmt & JExitMonitorStmt marks synchronized blocks of code from JEnterMonitorStmt to JExitMonitorStmt. JRetStmt JBreakpointStmt models a Breakpoint set by a Debugger (usually not relevant for static analyses) Immediate An Immediate has a given Type and consists of a Local (\"a Variable\", \"Sth that contains a Value\") or a Constant (\"Sth that is a Value\"). Type VoidType PrimaryType BooleanType, ByteType, CharType, ShortType, IntType, LongType, DoubleType, FloatType ReferenceType ClassType, ArrayType NullType Local 1 $i0 Whats this? A Local is a variable and its scope is inside its method i.e. no referencing from outside a method. Values can be assigned to Locals via JIdentityStmt or JAssignStmt. Constant represents a value itself. don't confuse it with a variable/Local which has a immutable (i.e. final) attribute. There exists a constant entity for every Type - that way all value types can have a representation. Expr // TODO Ref JArrayRef 1 $arr[1] referencing a position inside an array. JFieldRef (JStaticFieldRef & JInstanceFieldRef) 1 2 3 <SomePackage.ExampleClass: fieldname> // or $r1.<SomePackage.ExampleClass: fieldname> referencing a Field via its FieldSignature and if necessary (i.e. with JInstanceFieldRef) the corresponding Local instance that points to the object instance. IdentityRef The IdentityRef makes those implicit special value assignments explicit. JThisRef 1 @this: package.fruit.Banana represents the this pointer of the current class. JCaughtExceptionRef 1 @caughtexception represents the value of the thrown exception (caught by this exceptionhandler). JParameterRef 1 2 $i0 := @parameter0 $i1 := @parameter1 represents a parameter of a method, identified by its index.","title":"Jimple"},{"location":"jimple/#jimple","text":"What is Jimple? Jimple is the intermediate representation IR of Soot. Soots intention is to provide a simplified way to analyze JVM bytecode. For this purpose Jimple was designed as a representation of JVM bytecode which is human readable.","title":"Jimple"},{"location":"jimple/#jimple-grammar-structure","text":"Jimple mimics the JVMs class file structure. Therefore it is object oriented. A Single Class (or Interface) per file. Three-Address-Code which means there are no nested expressions. (nested expressions can be modeled via Locals that store intermediate calculation results.)","title":"Jimple Grammar Structure"},{"location":"jimple/#class-or-interface","text":"A class consists of Fields and Methods. It is referenced by its ClassType.","title":"Class (or Interface)"},{"location":"jimple/#field","text":"A Field is a piece of memory which can store a value that is accessible according to its visibility modifier. It is referenced by its FieldSignature.","title":"Field"},{"location":"jimple/#method-and-the-body","text":"The interesting part is a method. A method is a \"piece of code\" that can be executed. It is referenced by its MethodSignature and contains a StmtGraph that models the sequence of single instructions/statements (Stmts).","title":"Method and the Body"},{"location":"jimple/#signatures","text":"Everything that we can reference across a method (e.g. a Class, Interface, Method or Field) - which is basically every item//TODO:wording that is not a Local - has a Signature.","title":"Signatures"},{"location":"jimple/#trap","text":"A Trap is a mechanism to model exceptional flow.","title":"Trap"},{"location":"jimple/#stmt","text":"The main piece of Jimple is a Statement (Stmt). Stmts represent that can be executed by the JVM.","title":"Stmt"},{"location":"jimple/#branching-statements","text":"A BranchingStmt's job is to model the flow between Stmts.","title":"Branching Statements"},{"location":"jimple/#jgotostmt","text":"for unconditional flow","title":"JGotoStmt"},{"location":"jimple/#jifstmt","text":"for conditional flow depending on boolean Expression (AbstractConditionExpr) so they have two successor Stmt's","title":"JIfStmt"},{"location":"jimple/#jswitchstmt","text":"for conditional flow that behaves like a switch-case. It has #numberOfCaseLabels+1 (for default) successor Stmt's. All other Stmts are not manipulating the flow, which means they have a single successor Stmt as long as they are not exiting the flow inside a method.","title":"JSwitchStmt"},{"location":"jimple/#jreturnstmt-jreturnvoidstmt","text":"They end the execution/flow inside the current method and return (a value) to its caller.","title":"JReturnStmt &amp; JReturnVoidStmt"},{"location":"jimple/#jthrowstmt","text":"Ends the execution inside the current Method if the thrown exception is not caught by a Trap, which redirects the execution to an exceptionhandler","title":"JThrowStmt"},{"location":"jimple/#jinvokestmt","text":"transfers the control flow to another method until the called method returns.","title":"JInvokeStmt"},{"location":"jimple/#jassignstmt","text":"assigns a Value from the right handside to the left handside. On the left handside can occure a Local referencing a variable (i.e. a Local) or a FieldRef referencing a Field. On the right handside can be an expression (Expr), a Local, a FieldRef or a Constant.","title":"JAssignStmt"},{"location":"jimple/#jidentitystmt","text":"is semantically like the JAssignStmt and handles assignments of IdentityRef's to make implicit assignments explicit into the StmtGraph.","title":"JIdentityStmt"},{"location":"jimple/#jentermonitorstmt-jexitmonitorstmt","text":"marks synchronized blocks of code from JEnterMonitorStmt to JExitMonitorStmt.","title":"JEnterMonitorStmt &amp; JExitMonitorStmt"},{"location":"jimple/#jretstmt","text":"","title":"JRetStmt"},{"location":"jimple/#jbreakpointstmt","text":"models a Breakpoint set by a Debugger (usually not relevant for static analyses)","title":"JBreakpointStmt"},{"location":"jimple/#immediate","text":"An Immediate has a given Type and consists of a Local (\"a Variable\", \"Sth that contains a Value\") or a Constant (\"Sth that is a Value\").","title":"Immediate"},{"location":"jimple/#type","text":"VoidType","title":"Type"},{"location":"jimple/#primarytype","text":"BooleanType, ByteType, CharType, ShortType, IntType, LongType, DoubleType, FloatType","title":"PrimaryType"},{"location":"jimple/#referencetype","text":"ClassType, ArrayType NullType","title":"ReferenceType"},{"location":"jimple/#local","text":"1 $i0 Whats this? A Local is a variable and its scope is inside its method i.e. no referencing from outside a method. Values can be assigned to Locals via JIdentityStmt or JAssignStmt.","title":"Local"},{"location":"jimple/#constant","text":"represents a value itself. don't confuse it with a variable/Local which has a immutable (i.e. final) attribute. There exists a constant entity for every Type - that way all value types can have a representation.","title":"Constant"},{"location":"jimple/#expr","text":"// TODO","title":"Expr"},{"location":"jimple/#ref","text":"","title":"Ref"},{"location":"jimple/#jarrayref","text":"1 $arr[1] referencing a position inside an array.","title":"JArrayRef"},{"location":"jimple/#jfieldref-jstaticfieldref-jinstancefieldref","text":"1 2 3 <SomePackage.ExampleClass: fieldname> // or $r1.<SomePackage.ExampleClass: fieldname> referencing a Field via its FieldSignature and if necessary (i.e. with JInstanceFieldRef) the corresponding Local instance that points to the object instance.","title":"JFieldRef (JStaticFieldRef &amp; JInstanceFieldRef)"},{"location":"jimple/#identityref","text":"The IdentityRef makes those implicit special value assignments explicit.","title":"IdentityRef"},{"location":"jimple/#jthisref","text":"1 @this: package.fruit.Banana represents the this pointer of the current class.","title":"JThisRef"},{"location":"jimple/#jcaughtexceptionref","text":"1 @caughtexception represents the value of the thrown exception (caught by this exceptionhandler).","title":"JCaughtExceptionRef"},{"location":"jimple/#jparameterref","text":"1 2 $i0 := @parameter0 $i1 := @parameter1 represents a parameter of a method, identified by its index.","title":"JParameterRef"}]}